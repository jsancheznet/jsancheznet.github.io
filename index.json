[{"categories":null,"contents":"","date":"Nov 26","permalink":"https://jsanchez.net/projects/glow/","tags":null,"title":"Glow"},{"categories":null,"contents":"","date":"Feb 08","permalink":"https://jsanchez.net/projects/jsanchez_math/","tags":null,"title":"Math library"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://jsanchez.net/projects/pong/","tags":null,"title":"Pong"},{"categories":null,"contents":"TODO: Save a copy of the image, and make hugo render that instead of pulling it from the internet\nDear Imgui is an awesome immediate mode graphical user interface made by ocornut and contributors. It provides just about every GUI widget your game/app may need such as buttons, color pickers, graphs and so on. If that\u0026rsquo;s not enough, it\u0026rsquo;s also fast and super easy to use. Here\u0026rsquo;s a screenshot of someone\u0026rsquo;s game engine using Dear ImGui.\nCool uh?. It\u0026rsquo;s also easy to integrate into your project. The project\u0026rsquo;s documentation says it should take you less than 3 hours. But i personally build my projects using unity builds(also called single translation unit compilation). Dear ImGui can indeed be compiled and used in unity builds but i could not find any documentation that explains how. So here\u0026rsquo;s how i did it, hopefully this helps someone else.\n\r\r\rWhat are unity builds?\r\rThe standard way of building C/C++ projects is to build each .c/.cpp file separately (each instance is called a translation unit) and link all of them at the end producing the executable. In unity builds you include every single source code file in a single file thereby having a single translation unit at compile time. Instead of including headers, directly include C/C++ files. Once the preprocessor runs, there will be a single big file to compile.\n\r\r\rHow does the default dear imgui integration works\r\rLorem ipsum dolor sit amet, consectetur adipiscing elit. Nam consectetur felis nisi, sit amet pharetra libero viverra eget. Morbi sed nibh massa. Suspendisse massa neque, auctor in vestibulum sit amet, dignissim pretium ante. Mauris consectetur, nisl id dictum porttitor, est nisl tempus sem, vitae feugiat lorem lorem ac libero. Aenean tellus neque, tristique ac quam id, porttitor convallis quam. Nullam eget risus venenatis, tempor eros non, vulputate odio. Phasellus faucibus nisi sed libero accumsan, ut tempor erat consectetur. Aliquam ultricies dolor massa, in blandit velit porttitor ac. Aenean suscipit sagittis vestibulum. Nunc feugiat tempor erat. Donec pulvinar in ipsum nec commodo. Nulla sed tellus consequat purus rhoncus porttitor.\n\r\r\rProblems that arise in unity build\r\rLorem ipsum dolor sit amet, consectetur adipiscing elit. Nam consectetur felis nisi, sit amet pharetra libero viverra eget. Morbi sed nibh massa. Suspendisse massa neque, auctor in vestibulum sit amet, dignissim pretium ante. Mauris consectetur, nisl id dictum porttitor, est nisl tempus sem, vitae feugiat lorem lorem ac libero. Aenean tellus neque, tristique ac quam id, porttitor convallis quam. Nullam eget risus venenatis, tempor eros non, vulputate odio. Phasellus faucibus nisi sed libero accumsan, ut tempor erat consectetur. Aliquam ultricies dolor massa, in blandit velit porttitor ac. Aenean suscipit sagittis vestibulum. Nunc feugiat tempor erat. Donec pulvinar in ipsum nec commodo. Nulla sed tellus consequat purus rhoncus porttitor.\n\r\r\rSolving them\r\rLorem ipsum dolor sit amet, consectetur adipiscing elit. Nam consectetur felis nisi, sit amet pharetra libero viverra eget. Morbi sed nibh massa. Suspendisse massa neque, auctor in vestibulum sit amet, dignissim pretium ante. Mauris consectetur, nisl id dictum porttitor, est nisl tempus sem, vitae feugiat lorem lorem ac libero. Aenean tellus neque, tristique ac quam id, porttitor convallis quam. Nullam eget risus venenatis, tempor eros non, vulputate odio. Phasellus faucibus nisi sed libero accumsan, ut tempor erat consectetur. Aliquam ultricies dolor massa, in blandit velit porttitor ac. Aenean suscipit sagittis vestibulum. Nunc feugiat tempor erat. Donec pulvinar in ipsum nec commodo. Nulla sed tellus consequat purus rhoncus porttitor.\n","date":"Feb 22","permalink":"https://jsanchez.net/post/integrating_imgui_in_unity_builds/","tags":null,"title":"Integrating Dear ImGui in my projects"},{"categories":null,"contents":"Let\u0026rsquo;s say you want to allocate a struct that contains a pointer to other data that also needs allocation. The natural way to do it is calling malloc twice, one for the container and one for the data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* The natural way to allocate a struct and its data */ struct sample_type { float A; uint32_t B; uint8_t C; bool D; bool E; bool F; bool G; }; struct sample_struct { uint32_t Count; sample_type *Data; }; uint32_t Count = 5; sample_struct *Container = (sample_struct*)malloc(sizeof(sample_struct)); Container-\u0026gt;Count = Count; Container-\u0026gt;Data = (sample_type*)malloc(sizof(sample_type) * Count); // Do something to the data for(int i = 0; i \u0026lt; Container-\u0026gt;Count; i++) { Container-\u0026gt;Data[i] = {}; }   Something doesn\u0026rsquo;t feel right, these two allocations are going to be used together, one after the other but there is no guarantee they will be contiguous in memory, a cache miss is likely to happen everytime you access the data.\nHere is one way to use just a single allocation for the container and its data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* Using a single allocation */ struct sample_type { float A; uint32_t B; uint8_t C; bool D; bool E; bool F; bool G; }; struct sample_struct { uint32_t Count; sample_type *Data; }; uint32_t Count = 5; sample_struct *Container = (sample_struct*)malloc( sizeof(sample_struct) + sizeof(sample_type) * Count); Container-\u0026gt;Count = Count; Container-\u0026gt;Data = (sample_type*)(Container + 1); // Do something to the data for(int i = 0; i \u0026lt; Container-\u0026gt;Count; i++) { Container-\u0026gt;Data[i] = {}; }   If you ask me the second version is better, a single call to malloc and things that belong together are adjacent in memory.\nThere is something you need to be aware of while using this trick, Data should always be the last member of the struct.\n1 2 3 4 5 6 7 8 9 10 11 12 13  struct sample_struct { uint32_t Count; sample_type *Data; float Other; // WRONG, writing to this variable will overwrite values in the Data array and vice versa. }; struct sample_struct { uint32_t Count; float Other; // CORRECT, Remember to add struct members before the Data array.  sample_type *Data; };   ","date":"Jun 26","permalink":"https://jsanchez.net/post/avoiding-double-allocation-for-structs-and-data/","tags":null,"title":"Avoiding double allocation for structs and data"},{"categories":null,"contents":"If you have been using OpenGL for a while, you probably have a lot of shader files, maybe one for each programmable stage of the pipeline. At some point during development the directory that contains the shaders becomes a mess, managing and opening shader files in your editor becomes tedious. Luckily there\u0026rsquo;s a way to cram all the programmable shader stages in a single file, reducing the number of files at least by half and calm the neat freak inside.\nThese are the two things that make this trick possible.\n #ifdef - glsl\u0026rsquo;s preprocessor directive glShaderSource()  The idea is to separate different shader stages inside an #ifdef blocks and setting the corresponding #define directive for the shader stage.\nHere\u0026rsquo;s an example of what a shader might look like using this method.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #ifdef VERTEX_SHADER layout(location = 0) in vec3 Vertices; layout(location = 1) in vec3 Normals; uniform mat4 Model; uniform mat4 View; uniform mat4 Projection; void main() { gl_Position = Projection * View * Model * vec4(Vertices, 1.0); } #endif #ifdef FRAGMENT_SHADER uniform vec3 Color; out vec4 FragColor; void main() { FragColor = vec4(Color, 1.0); } #endif   Shader compilation looks something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  char *SourceFile = ReadTextFile(\u0026#34;MyShader.glsl\u0026#34;); // Compile Vertex Shader u32 VertexShaderObject = glCreateShader(GL_VERTEX_SHADER); char *VertexSource[2] = {\u0026#34;#version 330 core\\n#define VERTEX_SHADER\\n\u0026#34;, SourceFile}; glShaderSource(VertexShaderObject, 2, VertexSource, NULL); glCompileShader(VertexShaderObject); // Compile Fragment Shader u32 FragmentShaderObject = glCreateShader(GL_FRAGMENT_SHADER); char *FragmentSource[2] = {\u0026#34;#version 330 core\\n#define FRAGMENT_SHADER\\n\u0026#34;, SourceFile}; glShaderSource(FragmentShaderObject, 2, FragmentSource, NULL); glCompileShader(FragmentShaderObject); // Compile other shader stages  // Link program u32 FinalProgram = glCreateProgram(); glAttachShader(FinalProgram, VertexShaderObject); glAttachShader(FinalProgram, FragmentShaderObject); glLinkProgram(Result);   Notice that before calling glShaderSource we create an array of two pointers to char, the first one contains glsl\u0026rsquo;s #version preprocessor directive and the token that defines each shader. In the case of the vertex shader the first string looks like this \u0026ldquo;#version 330 core\\n#define VERTEX_SHADER\\n\u0026rdquo;. Sadly the #version directive needs to be the first line in a shader or else compilation fails. Setting the shader version like this is not as pretty or tidy as we may want but it\u0026rsquo;s a tradeoff i\u0026rsquo;m willing to make. When calling glShaderSource we set the second parameter to \u0026ldquo;2\u0026rdquo; indicating 2 strings and set the string to our newly created array.\nI hope you find this useful.\n","date":"Dec 09","permalink":"https://jsanchez.net/post/multiple-shaders-in-one-file/","tags":null,"title":"Multiple OpenGL shaders in a single file"},{"categories":null,"contents":"1 2 3 4 5 6 7 8 9 10 11  // Normalize an input value to 0,1 range. f32 Normalize(f32 Input, f32 Minimum, f32 Maximum) { return (Input - Minimum) / (Maximum - Minimum); } // Map one range onto another. Ex: Map Value Between 0-1800 to -20, 20. f32 Remap(f32 Input, f32 InputStart, f32 InputEnd, f32 OutputStart, f32 OutputEnd) { return (Input - InputStart) / (InputEnd - InputStart) * (OutputEnd - OutputStart) + OutputStart; }   \r\r\rGLSL\r\r1 2 3 4 5 6 7 8  // Grayscale FragmentColor = texture(SampledTexture, UV); float Average = (0.2126 * FragmentColor.r) + (0.7152 * FragmentColor.g) + (0.0722 * FragmentColor.b); FragmentColor = vec4(Average, Average, Average, 1.0); // Gamma Correction const float Gamma = 2.2; FragmentColor = pow(FragmentColor, vec3(1.0 / Gamma));   ","date":"Dec 07","permalink":"https://jsanchez.net/post/glsl-gists/","tags":null,"title":"Gists/Snippets"},{"categories":null,"contents":"Hybrid GPU\u0026rsquo;s are everywhere these days and yet it is not obvious how to run your program using the discrete GPU.\nI can think of 5 ways on how to get this done:\n Your software is popular enough that the GPU manufacturer includes an \u0026ldquo;application profile\u0026rdquo; for your software in their driver. This profile is basically the GPU configuration/settings for an executable. When your software has no application profile, the default graphic card depends on the global GPU settings but it is most likely the integrated gpu. You can manually create an application profile for your executable. The problem is that this profile will need to be manually created for each install. This may be useful if it\u0026rsquo;s a silly program you alone are going to run, but not really an option if you plan to ship software, even if it\u0026rsquo;s to family and friends. Oddly enough you can trick the driver to use an application profile made for other software by simply renaming your executable to something like \u0026ldquo;Doom3.exe\u0026rdquo;. Not really a solution but it\u0026rsquo;s comforting to know simple tricks like these still exist in 2019. Linking your program against nVidia\u0026rsquo;s defined libraries such as \u0026ldquo;nvapi64.dll\u0026rdquo;(The list of libraries is defined in the manual at the bottom of the page). Calling HMODULE Lib = LoadLibraryA(\u0026ldquo;nvapi64.dll\u0026rdquo;) in main function does the trick. This seems to be the old way of doing things, continue reading for a better solution. The best solution i know is to include the following code at global scope.  1 2 3 4 5 6 7 8 9  #ifdef _WIN32 extern \u0026#34;C\u0026#34; { // nVidia  __declspec( dllexport ) unsigned long int NvOptimusEnablement = 0x00000001; // AMD  __declspec( dllexport ) int AmdPowerXpressRequestHighPerformance = 1; } #endif   I have only tested the code on nVidia Optimus since it\u0026rsquo;s the only thing i have.\nIf you would like to know more, you should read the following manuals for Hybrid GPU\u0026rsquo;s, they are really really short (4-5 pages).\nnVidia\u0026rsquo;s hybrid gpu manual\nAMD\u0026rsquo;s hybrid gpu manual\n","date":"Dec 07","permalink":"https://jsanchez.net/post/handling-hybrid-gpus-in-windows/","tags":null,"title":"Handling Hybrid GPU's in Windows"},{"categories":null,"contents":"When you need a muli-line macro to have its own scope and behave as a regular function would, the naive way is to simply wrap the macro statements inside curly brackets. Now, time has passed and suddenly program compilation is failing, and as usual the compiler output is not helping. The naive macro implementation has come back to bite you.\nHere\u0026rsquo;s the naive implementation, let\u0026rsquo;s see how to fix it.\n1 2 3 4 5 6 7 8 9 10 11 12 13  #define MyMultipleLineMacro(Expr) \\ { \\ DoStuffRightHere(Expr); \\ DoMoreStuff; \\ } \\ void main() { if(1) MyMultipleLineMacro(Input); // Fails to compile!  else SomeOtherOperation; }   Let\u0026rsquo;s run the preprocessor and see how the macro was expanded:\n1 2 3 4 5 6 7 8 9 10  void main() { if(1) { DoStuffRightHere(Input); DoMoreStuff; }; // Fails to compile!  else SomeOtherOperation; }   To solve this problem, wrap the macro inside a do{}while(0) loop instead.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #define MyMultipleLineMacro(Expr) \\ do{ \\ DoStuffRightHere(Expr); \\ DoMoreStuff; \\ }while(0) \\ void main() { if(1) // Now the macro expands to valid C/C++.  do { DoStuffRightHere(Input); DoMoreStuff; }while(0); else SomeOtherOperation; return 0; }   Have a good day!\n","date":"Jun 22","permalink":"https://jsanchez.net/post/multi-line-function-macro/","tags":null,"title":"Making multi-line macros behave as a functions"}]