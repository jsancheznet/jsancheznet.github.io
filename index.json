[{"categories":null,"contents":"","date":"Nov 26","permalink":"https://jsanchez.net/projects/nito/","tags":null,"title":"In Progress: Nito"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jsanchez.net/projects/glow/","tags":null,"title":"Glow"},{"categories":null,"contents":"","date":"Dec 12","permalink":"https://jsanchez.net/projects/jsanchez_math/","tags":null,"title":"Math library"},{"categories":null,"contents":"","date":"Jul 11","permalink":"https://jsanchez.net/projects/dynamic_array/","tags":null,"title":"Dynamic array"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://jsanchez.net/projects/pong/","tags":null,"title":"Pong"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jsanchez.net/projects/bin2header/","tags":null,"title":"bin2header"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jsanchez.net/projects/gold_diggers/","tags":null,"title":"Gold Diggers"},{"categories":null,"contents":"\r/*\rForgive me for the awful code, this was my first time writing\rjavascript and i'm not sure what it can do or how it works so this is\ras janky as it gets.\r- Complaint #1\r- F#$% dynamic typing, mistakes are so annoying to find.\r- Complaint #2\r- F#$% writing code embedded in markdown\r*/\r//\r// Colors\r//\rvar Color_EerieBlack = \"#1F2022\";\rvar Color_White = \"#FFFFFF\";\rvar Color_OrangeYellowCrayola = \"#FFD479\";\rvar Color_CadetBlueCrayola = \"#B3B9C5\";\rvar Color_OrangeRed = \"#F86624\";\rvar Color_RoseMadder = \"#DB2B39\";\rvar Color_UnitedNationsBlue = \"#4A8FE7\";\rvar Color_WebsiteGrey = \"#1F2022\"\r// Default canvas size\rvar CanvasWidth = 800;\rvar CanvasHeight = 600;\r// Canvas objects for the different canvas id\rvar Canvas1;\rvar Canvas2;\r// Circles/Objects for the preview canvas (The first one)\rvar BlueCircle = { x: CanvasWidth / 2, y: CanvasHeight / 2, Radius: 40, Color: Color_UnitedNationsBlue};\rvar RedCircle = {x: CanvasWidth / 2 + 220, y: CanvasHeight / 2, Radius: 40, Color: Color_RoseMadder};\rvar GrayCircle = {x: CanvasWidth / 2 - 220, y: CanvasHeight / 2, Radius: 40, Color: Color_CadetBlueCrayola};\r// Circles/Objects for the second canvas (distance between centers canvas)\rvar BlueCircle2 = { x: CanvasWidth / 2, y: CanvasHeight / 2 - 100, Radius: 40, Color: Color_UnitedNationsBlue};\rvar GrayCircle2 = {x: CanvasWidth / 2, y: CanvasHeight / 2, Radius: 40, Color: Color_CadetBlueCrayola};\rvar LineColor2 = Color_WebsiteGrey;\rvar Distance2 = 0;\r// Math helpers\rfunction Magnitude(V)\r{\rreturn Math.sqrt(V.x * V.x + V.y * V.y);\r}\rfunction Normalize(V)\r{\rvar Length = Magnitude(V);\rvar Result = {x: V.x / Length, y: V.y / Length};\rreturn Result;\r}\rfunction Subtract(A, B)\r{\rreturn {x: A.x - B.x, y: A.y - B.y};\r}\rfunction ClearCanvas(Context, Color)\r{\rContext.fillStyle = 'white';\rContext.fillRect(0, 0, CanvasWidth, CanvasHeight);\r}\rfunction DrawCircle(Context, Circle)\r{\rContext.fillStyle = Circle.Color;\rContext.beginPath();\rContext.arc(Circle.x, Circle.y, Circle.Radius, 0, Math.PI * 2, true);\rContext.fill();\r}\rfunction GetMousePosition(Canvas, Event)\r{\rvar Rect = Canvas.getBoundingClientRect();\rvar Root = document.documentElement;\rvar MouseX = Event.clientX - Rect.left;\rvar MouseY = Event.clientY - Rect.top;\rreturn { x: MouseX, y: MouseY };\r}\rfunction Canvas1_MouseClick(Event)\r{\rBlueCircle.x = CanvasWidth / 2;\rBlueCircle.y = CanvasHeight / 2;\rRedCircle.x = CanvasWidth / 2 + 220;\rRedCircle.y = CanvasHeight / 2;\rGrayCircle.x = CanvasWidth / 2 - 220;\rGrayCircle.y = CanvasHeight / 2;\r}\rfunction Canvas1_MouseMove(Event)\r{\r// Move the blue circle to mouse position\rvar MousePosition = GetMousePosition(Canvas1, Event);\rBlueCircle.x = MousePosition.x;\rBlueCircle.y = MousePosition.y;\r// Check for collision with the static circle\rvar dx = GrayCircle.x - BlueCircle.x;\rvar dy = GrayCircle.y - BlueCircle.y;\rvar Distance = Math.sqrt(dx * dx + dy * dy);\rif(Distance \r\r\rWhat is collision detection?\r\rWikipedia defines collision detection as \u0026ldquo;the computational problem of detecting the intersection of two or more objects\u0026rdquo;. In real life you cannot go through objects but in a computer simulation objects can overlap and go through each other. In order to resemble reality we need a way to detect when objects are overlapping.\nImagine two billiard balls, one of them is moving towards the other. In the real world they collide and each ball goes in a different direction. When programming a simulation we need to check every frame for collision, and when a collision is found resolve it.\nCollision detection is a broad and complex problem, and if that wasn\u0026rsquo;t enough it is also coupled with simulations and physics.\nIn this article I will only talk about collision detection of two or more circles in 2 dimensions(although the same algorithm works for 3D spheres), and to make it a little more fun I will explain one of the many ways of making things interact besides checking if they are colliding or not.\nHere\u0026rsquo;s a preview of what we will be implementing.\n\n\r\r\rPrerequisites\r\rI have to draw the knowledge required line somewhere, and this is it. Nothing of what i\u0026rsquo;m about to explain/use is hard or complex. You can learn it in a few minutes. The internet is full of guides and this one will do the job just fine.\nThese are the things you need to know:\n What is a circle\u0026rsquo;s radius What is a vector Subtracting two vectors Magnitude of a vector Normalizing a vector Scaling a vector  I will be programming in C since it\u0026rsquo;s my favourite language, feel free to translate the code to your language and style of your choice. Let\u0026rsquo;s start by defining vector and circle structs.\n1 2 3 4 5 6 7 8 9 10  typedef struct vec2 { float x, y; } vec2; typedef struct circle { vec2 Center; // Center are the coordinates of the circle center  float Radius; } circle;   Now let\u0026rsquo;s define some functions we will need.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  vec2 Subtract(vec2 A, vec2 B) { vec2 Result = {0}; Result.x = A.x - B.x; Result.y = A.y - B.y; return Result; } float Magnitude(vec2 A) { return sqrtf(A.x * A.x + A.y * A.y); } vec2 Normalize(vec2 A) { vec2 Result = {0}; float Length = Magnitude(A); Result.x = A.x / Length; Result.y = A.y / Length; return Result; }   \r\r\rChecking if two circles collide\r\rChecking if two circles collide is really easy. If the distance between the two circle\u0026rsquo;s center is less than the sum of their radii, they are colliding. Play around with the following example and you should get the idea. The black line represents the distance between the two circles, and the radii sum is just the sum of both circle\u0026rsquo;s radii.\n\n\r\r\rThe code\r\rThe following function returns just a boolean, wether the input circles are colliding or not.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  bool Collide(circle A, circle B) { vec2 Difference = Subtract(A.Center, B.Center); float Distance = Magnitude(Difference); float RadiiSum = A.Radius + B.Radius; if(Distance \u0026lt; RadiiSum) { return true; } else { return false; } }   \r\r\rBasic collision interaction\r\rHere we are going to do the red and blue circle interaction seen on the first section.\nIn order to move the circles apart we need what is called the \u0026ldquo;minimum translation vector\u0026rdquo;, in other words it\u0026rsquo;s how much the circles are overlapping. With this length, we can simply move both circles apart or just one as i did with the red one.\nTo get the minimum translation vector we subtract the distance from the radiisum and take the absolute value of the result. After that we need to get the normalized direction vector of the distance. After that we just need to add the movement to the red circle.\nMath in words makes everyone dizzy, and i\u0026rsquo;m not good at explaining. Code is a more elegant medium.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void Simulate(circle A, circle *B) { // Be aware that circle B is a pointer, this is because we are  // going to update it\u0026#39;s position. B is the same as the red circle  // in the previous demo window.  // Abs -\u0026gt; Absolute value  // MTD -\u0026gt; Minimum translation distance  if(Collide(A, *B)) { float RadiiSum = A.Radius + B-\u0026gt;Radius; float MTD = Abs(Distance - RadiiSum); vec2 Direction = Normalize(Subtract(A.Center, B-\u0026gt;Center)); B-\u0026gt;x += Direction.x * MTV; B-\u0026gt;Y += Direction.y * MTV; } }   This last section is a bit more complicated, if you don\u0026rsquo;t understand something, i recommend doing sketches on pen and paper, that usually helps me.\nI\u0026rsquo;m happy you read this whole thing, thank you, you are awesome.\nUntil next time.\n","date":"Apr 05","permalink":"https://jsanchez.net/post/collision_circle_circle/","tags":null,"title":"Collision Detection: Circle vs Circle"},{"categories":null,"contents":"Dear Imgui is an awesome C/C++ immediate mode graphical user interface (GUI) made by ocornut. It provides just about every widget you might need, buttons, color pickers, plots and many, many more. It\u0026rsquo;s also fast and super easy to use.\nHere\u0026rsquo;s a screenshot of someone\u0026rsquo;s game using Dear ImGui.\nCool uh?. It\u0026rsquo;s easy to integrate into your project. The official documentation says integration should take you less than 3 hours. That\u0026rsquo;s a lot of features and awesomeness for such a short amount of time.\nI personally build my projects using unity builds(also called single translation unit compilation). I could not find any guide on how to setup dear imgui for this type of build system.\nSo here\u0026rsquo;s how i did it.\n\r\r\rWhat are unity builds?\r\rThe standard way of building C/C++ applications is to build each .c/.cpp file separately (each instance is called a translation unit) and link all of them at the linker stage producing the executable.\nUnity build\u0026rsquo;s basic idea is to include every .c/.cpp source file in a single file, and after the preprocessor runs you have just one huge file to compile. Unity builds also have faster compilation time, even while rebuilding the whole project each time. I have seen codebases bigger than 150000 lines compile in a second. really.\n1 2 3 4 5 6 7 8  #include \u0026#34;my_other_file.cpp\u0026#34;#include \u0026#34;my_other_file2.cpp\u0026#34;#include \u0026#34;my_other_file3.cpp\u0026#34; int main() { // My program... }   1  jsanchez@scarlet:~$ cl main.cpp   If you are not compiling your code like this, you don\u0026rsquo;t need to follow this guide. Head over to the official integration guide.\n\r\r\rCopying files to your project\r\rStart by downloading Dear ImGui. We are going to select a few source code files from the zip and copy them to our project, feel free to extract it wherever you prefer.\nImGui is meant to be used on many operating systems, alongside many platform libraries and every major rendering api. In order to do its job it needs to read keyboard/mouse/gamepad input, upload textures/buffers to the gpu and render. There\u0026rsquo;s a lot of glue code to be done here. Luckily there are many \u0026ldquo;backends\u0026rdquo; ready for you to use.\nIn my case i\u0026rsquo;m using libSDL for my platform code and OpenGL 3.3 as my rendering api. So i need to use the two following backends imgui_impl_sdl and imgui_\rimgui_impl_opengl3. You can find all available backends inside the backends directory.\nNow, create a folder inside your project to hold the Dear ImGui files. Copy the following files from the root directory of the Dear ImGui zip file.\nimconfig.h\rimgui.h\rimgui.cpp\rimgui_draw.cpp\rimgui_demo.cpp\rimgui_internal.h\rimgui_tables.cpp\rimgui_widgets.cpp\rimstb_rectpack.h\rimstb_textedit.h\rimstb_truetype.h\rAlso copy the following files from the backends directory. If you are not using libSDL and OpenGL you will need to replace the following files with whatever files you need.\nimgui_impl_opengl3.cpp\rimgui_impl_opengl3.h\rimgui_impl_opengl3_loader.h\rimgui_impl_sdl.h\rimgui_impl_sdl.cpp\rRemember to add the new directory holding this files to the project\u0026rsquo;s include path.\nWe are now ready to open our text editor, and because we are using unity builds:\nInstead of doing this.\n1 2 3  #include \u0026#34;imgui.h\u0026#34;#include \u0026#34;imgui_impl_sdl.h\u0026#34;#include \u0026#34;imgui_impl_opengl3.h\u0026#34;  We do this!\n1 2 3 4 5 6 7  #include \u0026#34;imgui.cpp\u0026#34;#include \u0026#34;imgui_tables.cpp\u0026#34;#include \u0026#34;imgui_widgets.cpp\u0026#34;#include \u0026#34;imgui_draw.cpp\u0026#34;#include \u0026#34;imgui_demo.cpp\u0026#34; // You don\u0026#39;t need this file, i use it as gui reference#include \u0026#34;imgui_impl_opengl3.cpp\u0026#34;#include \u0026#34;imgui_impl_sdl.cpp\u0026#34;  We are almost ready to use Dear ImGui. There\u0026rsquo;s just one more problem.\n\r\r\rOpenGL loader clash\r\rOpenGL is generally implemented in the video driver, and before using it you need to query the driver for function pointers. ImGui has it\u0026rsquo;s own loader but it\u0026rsquo;s not a replacement for a full opengl loader like glad. Since you now have two loaders, your code will not compile because there will be multiple function pointer redefinitions.\nTo solve this #define IMGUI_IMPL_OPENGL_LOADER_CUSTOM before you include your OpenGL loader.\n1 2  #define IMGUI_IMPL_OPENGL_LOADER_CUSTOM #include \u0026#34;glad.c\u0026#34;  You are now ready to write some code. You need to write some minimal boilerplate code to get ImGui up and running. I recommend checking the examples directory inside ImGui\u0026rsquo;s zip file and running ImGui\u0026rsquo;s example demo window to get an idea of what can be done. I hope this helps.\nSee you next time!\n","date":"Feb 22","permalink":"https://jsanchez.net/post/integrating_imgui_in_unity_builds/","tags":null,"title":"Integrating Dear ImGui in unity builds"},{"categories":null,"contents":"Let\u0026rsquo;s say you want to allocate a struct that contains a pointer to other data that also needs allocation. The natural way to do it is calling malloc twice, one for the container and one for the data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* The natural way to allocate a struct and its data */ struct sample_type { float A; uint32_t B; uint8_t C; bool D; bool E; bool F; bool G; }; struct sample_struct { uint32_t Count; sample_type *Data; }; uint32_t Count = 5; sample_struct *Container = (sample_struct*)malloc(sizeof(sample_struct)); Container-\u0026gt;Count = Count; Container-\u0026gt;Data = (sample_type*)malloc(sizof(sample_type) * Count); // Do something to the data for(int i = 0; i \u0026lt; Container-\u0026gt;Count; i++) { Container-\u0026gt;Data[i] = {}; }   Something doesn\u0026rsquo;t feel right, these two allocations are going to be used together, one after the other but there is no guarantee they will be contiguous in memory, a cache miss is likely to happen everytime you access the data.\nHere is one way to use just a single allocation for the container and its data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* Using a single allocation */ struct sample_type { float A; uint32_t B; uint8_t C; bool D; bool E; bool F; bool G; }; struct sample_struct { uint32_t Count; sample_type *Data; }; uint32_t Count = 5; sample_struct *Container = (sample_struct*)malloc( sizeof(sample_struct) + sizeof(sample_type) * Count); Container-\u0026gt;Count = Count; Container-\u0026gt;Data = (sample_type*)(Container + 1); // Do something to the data for(int i = 0; i \u0026lt; Container-\u0026gt;Count; i++) { Container-\u0026gt;Data[i] = {}; }   If you ask me the second version is better, a single call to malloc and things that belong together are adjacent in memory.\nThere is something you need to be aware of while using this trick, Data should always be the last member of the struct.\n1 2 3 4 5 6 7 8 9 10 11 12 13  struct sample_struct { uint32_t Count; sample_type *Data; float Other; // WRONG, writing to this variable will overwrite values in the Data array and vice versa. }; struct sample_struct { uint32_t Count; float Other; // CORRECT, Remember to add struct members before the Data array.  sample_type *Data; };   ","date":"Jun 26","permalink":"https://jsanchez.net/post/avoiding-double-allocation-for-structs-and-data/","tags":null,"title":"Avoiding double allocation for structs and data"},{"categories":null,"contents":"If you have been using OpenGL for a while, you probably have a lot of shader files, maybe one for each programmable stage of the pipeline. At some point during development the directory that contains the shaders becomes a mess, managing and opening shader files in your editor becomes tedious. Luckily there\u0026rsquo;s a way to cram all the programmable shader stages in a single file, reducing the number of files at least by half and calm the neat freak inside.\nThese are the two things that make this trick possible.\n #ifdef - glsl\u0026rsquo;s preprocessor directive glShaderSource()  The idea is to separate different shader stages inside an #ifdef blocks and setting the corresponding #define directive for the shader stage.\nHere\u0026rsquo;s an example of what a shader might look like using this method.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #ifdef VERTEX_SHADER layout(location = 0) in vec3 Vertices; layout(location = 1) in vec3 Normals; uniform mat4 Model; uniform mat4 View; uniform mat4 Projection; void main() { gl_Position = Projection * View * Model * vec4(Vertices, 1.0); } #endif #ifdef FRAGMENT_SHADER uniform vec3 Color; out vec4 FragColor; void main() { FragColor = vec4(Color, 1.0); } #endif   Shader compilation looks something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  char *SourceFile = ReadTextFile(\u0026#34;MyShader.glsl\u0026#34;); // Compile Vertex Shader u32 VertexShaderObject = glCreateShader(GL_VERTEX_SHADER); char *VertexSource[2] = {\u0026#34;#version 330 core\\n#define VERTEX_SHADER\\n\u0026#34;, SourceFile}; glShaderSource(VertexShaderObject, 2, VertexSource, NULL); glCompileShader(VertexShaderObject); // Compile Fragment Shader u32 FragmentShaderObject = glCreateShader(GL_FRAGMENT_SHADER); char *FragmentSource[2] = {\u0026#34;#version 330 core\\n#define FRAGMENT_SHADER\\n\u0026#34;, SourceFile}; glShaderSource(FragmentShaderObject, 2, FragmentSource, NULL); glCompileShader(FragmentShaderObject); // Compile other shader stages  // Link program u32 FinalProgram = glCreateProgram(); glAttachShader(FinalProgram, VertexShaderObject); glAttachShader(FinalProgram, FragmentShaderObject); glLinkProgram(Result);   Notice that before calling glShaderSource we create an array of two pointers to char, the first one contains glsl\u0026rsquo;s #version preprocessor directive and the token that defines each shader. In the case of the vertex shader the first string looks like this \u0026ldquo;#version 330 core\\n#define VERTEX_SHADER\\n\u0026rdquo;. Sadly the #version directive needs to be the first line in a shader or else compilation fails. Setting the shader version like this is not as pretty or tidy as we may want but it\u0026rsquo;s a tradeoff i\u0026rsquo;m willing to make. When calling glShaderSource we set the second parameter to \u0026ldquo;2\u0026rdquo; indicating 2 strings and set the string to our newly created array.\nI hope you find this useful.\n","date":"Dec 09","permalink":"https://jsanchez.net/post/multiple-shaders-in-one-file/","tags":null,"title":"Multiple OpenGL shaders in a single file"},{"categories":null,"contents":"1 2 3 4 5 6 7 8 9 10 11  // Normalize an input value to 0,1 range. f32 Normalize(f32 Input, f32 Minimum, f32 Maximum) { return (Input - Minimum) / (Maximum - Minimum); } // Map one range onto another. Ex: Map Value Between 0-1800 to -20, 20. f32 Remap(f32 Input, f32 InputStart, f32 InputEnd, f32 OutputStart, f32 OutputEnd) { return (Input - InputStart) / (InputEnd - InputStart) * (OutputEnd - OutputStart) + OutputStart; }   \r\r\rGLSL\r\r1 2 3 4 5 6 7 8  // Grayscale FragmentColor = texture(SampledTexture, UV); float Average = (0.2126 * FragmentColor.r) + (0.7152 * FragmentColor.g) + (0.0722 * FragmentColor.b); FragmentColor = vec4(Average, Average, Average, 1.0); // Gamma Correction const float Gamma = 2.2; FragmentColor = pow(FragmentColor, vec3(1.0 / Gamma));   ","date":"Dec 07","permalink":"https://jsanchez.net/post/glsl-gists/","tags":null,"title":"Gists/Snippets"},{"categories":null,"contents":"Hybrid GPU\u0026rsquo;s are everywhere these days and yet it is not obvious how to run your program using the discrete GPU.\nI can think of 5 ways on how to get this done:\n Your software is popular enough that the GPU manufacturer includes an \u0026ldquo;application profile\u0026rdquo; for your software in their driver. This profile is basically the GPU configuration/settings for an executable. When your software has no application profile, the default graphic card depends on the global GPU settings but it is most likely the integrated gpu. You can manually create an application profile for your executable. The problem is that this profile will need to be manually created for each install. This may be useful if it\u0026rsquo;s a silly program you alone are going to run, but not really an option if you plan to ship software, even if it\u0026rsquo;s to family and friends. Oddly enough you can trick the driver to use an application profile made for other software by simply renaming your executable to something like \u0026ldquo;Doom3.exe\u0026rdquo;. Not really a solution but it\u0026rsquo;s comforting to know simple tricks like these still exist in 2019. Linking your program against nVidia\u0026rsquo;s defined libraries such as \u0026ldquo;nvapi64.dll\u0026rdquo;(The list of libraries is defined in the manual at the bottom of the page). Calling HMODULE Lib = LoadLibraryA(\u0026ldquo;nvapi64.dll\u0026rdquo;) in main function does the trick. This seems to be the old way of doing things, continue reading for a better solution. The best solution i know is to include the following code at global scope.  1 2 3 4 5 6 7 8 9  #ifdef _WIN32 extern \u0026#34;C\u0026#34; { // nVidia  __declspec( dllexport ) unsigned long int NvOptimusEnablement = 0x00000001; // AMD  __declspec( dllexport ) int AmdPowerXpressRequestHighPerformance = 1; } #endif   I have only tested the code on nVidia Optimus since it\u0026rsquo;s the only thing i have.\nIf you would like to know more, you should read the following manuals for Hybrid GPU\u0026rsquo;s, they are really really short (4-5 pages).\nnVidia\u0026rsquo;s hybrid gpu manual\nAMD\u0026rsquo;s hybrid gpu manual\n","date":"Dec 07","permalink":"https://jsanchez.net/post/handling-hybrid-gpus-in-windows/","tags":null,"title":"Handling Hybrid GPU's in Windows"},{"categories":null,"contents":"When you need a muli-line macro to have its own scope and behave as a regular function would, the naive way is to simply wrap the macro statements inside curly brackets. Now, time has passed and suddenly program compilation is failing, and as usual the compiler output is not helping. The naive macro implementation has come back to bite you.\nHere\u0026rsquo;s the naive implementation, let\u0026rsquo;s see how to fix it.\n1 2 3 4 5 6 7 8 9 10 11 12 13  #define MyMultipleLineMacro(Expr) \\ { \\ DoStuffRightHere(Expr); \\ DoMoreStuff; \\ } \\ void main() { if(1) MyMultipleLineMacro(Input); // Fails to compile!  else SomeOtherOperation; }   Let\u0026rsquo;s run the preprocessor and see how the macro was expanded:\n1 2 3 4 5 6 7 8 9 10  void main() { if(1) { DoStuffRightHere(Input); DoMoreStuff; }; // Fails to compile!  else SomeOtherOperation; }   To solve this problem, wrap the macro inside a do{}while(0) loop instead.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #define MyMultipleLineMacro(Expr) \\ do{ \\ DoStuffRightHere(Expr); \\ DoMoreStuff; \\ }while(0) \\ void main() { if(1) // Now the macro expands to valid C/C++.  do { DoStuffRightHere(Input); DoMoreStuff; }while(0); else SomeOtherOperation; return 0; }   Have a good day!\n","date":"Jun 22","permalink":"https://jsanchez.net/post/multi-line-function-macro/","tags":null,"title":"Making multi-line macros behave as a functions"}]