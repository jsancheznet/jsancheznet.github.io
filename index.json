[{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jsanchez.net/projects/glow/","tags":null,"title":"Glow"},{"categories":null,"contents":"","date":"Nov 06","permalink":"https://jsanchez.net/projects/action_roguelike/","tags":null,"title":"Action Roguelike"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://jsanchez.net/projects/nito/","tags":null,"title":"Toasty"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://jsanchez.net/projects/pong/","tags":null,"title":"Pong"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jsanchez.net/projects/gold_diggers/","tags":null,"title":"Gold Diggers"},{"categories":null,"contents":"","date":"Dec 12","permalink":"https://jsanchez.net/projects/jsanchez_math/","tags":null,"title":"Math library"},{"categories":null,"contents":"These are my notes for Tom Looman\u0026rsquo;s course Professional Game Development in C++ and Unreal Engine. These notes mainly consist of things i did not know or understand at the time, and things i did not want to forget. This is mainly for myself.\nAbout Unreal Engine Naming and Conventions Editor Tips C++ Blueprint Tips Development Tips Math Tips Interfaces Multiplayer Collision UMG Materials Sound Anim Blueprints AI EQS Curves Commands and Cheats Savegame System Data Tables Data Assets Soft and Hard References Profiling Cooking/Packaging Performance Tips About Unreal Engine\rCoordinate System\rX is Forward\nY is Right\nZ is Up\nTransforms\rA transform holds Location, Rotation \u0026amp; Scale\nControl Rotation\rControl rotation refers to the rotation of the player controller. The controller\u0026rsquo;s rotation has priority over the pawn it is controlling. Setting the pawn rotation will do nothing if it is being controlled by a controller. You will need to set the controller rotation instead. So if your pawn is having problems rotating, it might be that the controller is overwriting it.\nComponents and transforms\rComponents that derive from USceneComponent have a transform (relative to its parent). So, remember to attach them to their correct parent.\nComponents that derive from UActorComponent don\u0026rsquo;t have a transform.\nNaming and Conventions\rUnreal Engine Prefixes\rUnreal uses prefixes when naming their classes, these are the most common ones.\nPrefix Meaning U Derives from UObject A Derives from Actor F Structs E Enums I Interfaces Source Files\rIt is customary to add a prefix to all your source code files. This makes files easily distinguishable from engine files and other projects.\nFor example we could choose the prefix \u0026lsquo;RPG\u0026rsquo; for a project and our source files could be \u0026ldquo;RPGMyCharacter.h/cpp\u0026rdquo;.\nEditor Tips\rResetting variables to their default state\rIn the editor, there\u0026rsquo;s a little arrow next to variables, clicking reset\u0026rsquo;s the value to it\u0026rsquo;s default state.\nSlomo Command\rThe \u0026ldquo;slomo\u0026rdquo; command will slow or accelerates simulation time. 1 is the default value. Between 0 and 1, it becomes slower. 1+ is faster.\nMake warnings more prominent\rIt\u0026rsquo;s a good idea to make warnings easier to see and in your face. Turn on \u0026ldquo;Promote Output Log Warnings During PIE\u0026rdquo;.\nAsset Searching Shortcut\rCtrl+P opens a window to search for assets. It\u0026rsquo;s really fast since as soon as you press the shortcut you can start typing.\nMove around in PIE without stopping the simulation\rPress F8 while playing in editor to be able to move around without stopping the simulation. Press F8 again to go back to your camera view.\nSomething should be working but its not?\rThe unreal editor is good but not perfect. Sometimes weird things happen that make no sense. Maybe a file is not appearing on a dropdown or something that you think should be there/working is not.\nTry restarting the editor, recompiling, re-saving the filess, hell maybe even restart your computer.\nC\u0026#43;\u0026#43;\rWhenever possible, forward declare\rTry to not include headers in C++ class definitions. It is better to forward declare them for faster compilation times. Including headers will result in huge translation units.\nOrder your code\rIt\u0026rsquo;s a good idea to order your functions in the order they might get executed. For example, the constructor of a class should be near the top of the file. BeginPlay should also be near the top of the file. Mantaining a consistency like this will make finding functions faster and easier.\nStepping into engine code\rTo use the debugger with Unreal\u0026rsquo;s engine code, you need to download the editor symbols for debugging. This can be done from Epic Game\u0026rsquo;s Launcher.\nStructs\rWhen declaring structs in unreal, remember to prefix them with \u0026lsquo;F\u0026rsquo; and add the required macro\u0026rsquo;s for unreal\u0026rsquo;s header tool.\nExample:\n1 2 3 4 5 6 7 8 USTRUCT() struct FMyStruct { GENERATED_BODY() UPROPERTY() int MyVar; }; Casting\rUsing regular C-style casting is not recommended. Unreal has it\u0026rsquo;s own way of casting and it\u0026rsquo;s done using an existing template.\n1 ClassToCastTo *MyPtr = Cast\u0026lt;ClassToCastTo\u0026gt;(Pointer); Static Class\rSometimes you need a variable that does not need to point to a instance of a class, but to a class type. In order to get the class type we can call a method called StaticClass().\n1 ClassName::StaticClass(); Asserts\r\u0026ldquo;ensure\u0026rdquo; will assert but continue the game after. By default it will only halt execution once.\n\u0026ldquo;ensureAlways\u0026rdquo; is another flavor of ensure, but this one will always halt execution.\n\u0026ldquo;check\u0026rdquo; will halt execution when it\u0026rsquo;s evaluation is false.\n\u0026ldquo;ensureMsgf\u0026rdquo; not only triggers the debugger when failing, but it also logs a message. This message appears in a red color inside the editor.\nAActor::PostInitializeComponents\rThis function runs before BeginPlay. It\u0026rsquo;s a good place to bind to component events, like: \u0026ldquo;OnComponentHit\u0026rdquo;.\nConst UFUNCTION\rSetting a UFUNCTION to const will make it appear as a green node with no execution pin inside blueprints.\nPerformance\rDon\u0026rsquo;t call \u0026ldquo;GetAllActorsOfClass\u0026rdquo;. It iterates through every actor on the world to find them.\nIterating through all actors in a world\rTo loop over all the classes in the world, we can use the class \u0026ldquo;TActorIterator\u0026rdquo;.\nIt\u0026rsquo;s what \u0026ldquo;GetAllActorsOfClass\u0026rdquo; uses behind the curtain.\n1 2 3 4 5 for(TActorIterator\u0026lt;SMyClass\u0026gt;It;It(GetWorld(); It++)) { SMyClass *Ptr = *It; // Do stuff } Destroy Actor in X Seconds\rThe following function will set an actor to be destroyed in X seconds\n1 Actor-\u0026gt;SetLifeSpan(Seconds); Enable Ragdoll\rTo enable ragdoll behaviour in C++, call:\n1 2 GetMesh()-\u0026gt;SetAllBodiesSimulatePhysics(true); GetMesh()-\u0026gt;SetCollisionProfileName(\u0026#34;Ragdoll\u0026#34;); Creating a reusable function library\rTo create a reusable function library, create a class that inherits from \u0026ldquo;UBlueprintFunctionLibrary\u0026rdquo;. Make all the functions static, and expose them to Blueprints. An example of this is \u0026ldquo;UGameplayStatics\u0026rdquo;.\nStatic member functions\rStatic member functions are accessed by the class\u0026rsquo;s name as namespace.\n1 MyClass::MyStaticFunction(); Timers with parameters\rYou can create a timer that executes a function with parameters.\n1 2 3 4 5 6 FTimerHandle Handle; FTimerDelegate Delegate; Delegate.BindUFunction(this, \u0026#34;FunctionName\u0026#34;, FirstParameter); GetWorldTimerManager().SetTimer(Handle, Delegate, Time, false); This will run FunctionName with parameters first Parameter in Time seconds\nUnposses a Pawn/Character\r1 MyController-\u0026gt;Unposses(); Creating CVars (console variables)\rTo create a Cvar, go the .cpp file and at the top of the file declare the CVar.\n1 2 3 4 static TAutoConsoleVariable\u0026lt;bool\u0026gt; CVarVariableName(TEXT(\u0026#34;My.Variable\u0026#34;), defaultvalue(true), TEXT(\u0026#34;Help text that says what this variable is for\u0026#34;), ECVF_Cheat) // To get the value bool Result = CVarVariableName.GetValueOnGameThread(); Instantiating new objects\rThe function NewObject(\u0026hellip;) is used to instantiate new objecs. The paramater \u0026ldquo;Outer\u0026rdquo; is who owns this object.\nCreating blueprints from UObject derived classes\rWhenever you need to create a blueprint from a UObject derived class, you need to mark the class as Blueprintable\n1 UCLASS(Blueprintable) C\u0026#43;\u0026#43; Functions marked as BlueprintNativeEvent\rWhen marking UFUNCTIONS as BlueprintNativeEvent, the C++ implementation name must append \u0026ldquo;_Implementation(\u0026hellip;)\u0026rdquo; to it\u0026rsquo;s definition.\n1 2 3 4 5 6 7 8 9 // Header UFUNCTION(BlueprintNativeEvent) void MyFunction(); // Implementation void MyClass::MyFunction_Implementation() { // Code } Accessing UWorld from blueprint classes derived from UObject\rClasses that are derived from UObject don\u0026rsquo;t have access to UWorld when used in blueprints. This severely limits what can be donde in blueprints. To fix this, override the GetWorld function.\n1 UWorld *GetWorld() const override; GameplayTags in C\u0026#43;\u0026#43;\rWe cannot create GameplayTags in C++. They must be added using the unreal editor.\nBut we can request and access gameplay tags from C++.\n1 2 // Request a GameplayTag to the engine FGameplayTag MyTag = FGameplayTag::RequestGameplayTag(\u0026#34;Tag.MyTag\u0026#34;); Functions not appearing in blueprints\rIf a function is not showing up in the blueprint function list, it\u0026rsquo;s probably missing a UFUNCTION specifier. Try adding \u0026ldquo;BlueprintCallable\u0026rdquo;.\n1 2 UFUNCTION(BlueprintCallable) MyFunction(); ECollisionChannel Variables in C\u0026#43;\u0026#43;\rCreating a variable of type \u0026ldquo;ECollisionChannel\u0026rdquo; does not compile. You need to do it in the following way:\n1 TEnumAsByte\u0026lt;ECollisionChannel\u0026gt; Channel; GameplayTags Container in C\u0026#43;\u0026#43;\rWhen we need a container of gameplaytags, it\u0026rsquo;s a good idea to use FGameplayTagContainer. It\u0026rsquo;s an array fo gameplay tags with a bunch of helper functions implemented.\n1 FGameplayTagContainer MyContainer; Blueprint Tips\rHow to know what class/namespace does a node belong to\rA good way to know what class/namespace a blueprint node belongs to is to mouse over it and looking at it\u0026rsquo;s target.\nVariables or Functions not appearing in the editor\rSometimes variables or functions won\u0026rsquo;t appear in the blueprint editor, most likely you forgot to add a property specifier. Check your C++ code.\nGet Default Values of a Class\rTo get a class default variable values and settings, you can use the node \u0026ldquo;GetClassDefaults\u0026rdquo;.\nBlueprint Performance Tips\rIn project settings, you can disable tick in blueprints by default. Setting this makes using the tick function a conscious decision.\n\u0026ldquo;Project Settings -\u0026gt; Blueprints -\u0026gt; Can blueprints tick by default\u0026rdquo;.\nDevelopment Tips\rUse Debug Shapes\rSometimes drawing things in-game can be useful for debugging. Unreal has a bunch of easy to use functions to draw things such as boxed, spheres, lines\u0026hellip;\n1 2 3 4 5 6 7 8 9 DrawDebugPoint(...); DrawDebugSphere(...); DrawDebugCircle(...); DrawDebugCircle(...); DrawDebugSolidBox(...); DrawDebugBox(...); DrawDebugLine(...); DrawDebugDirectionalArrow(...); DrawDebugCrosshairs(...); Get Component By Class\rUse GetComponentByClass to find a specific component. This is faster than casting to player and accessing the component from player. This also has less error of invalid pointer, casting might fail.\nTeleporting Actors\rWhen you need to teleport an actor somewhere, it\u0026rsquo;s a good idea to use the built-in function \u0026ldquo;TeleportTo\u0026rdquo;. It handles a lot of edge cases when teleporting something. Such as checking for collision, valid location and more edge cases.\n1 Actor-\u0026gt;TeleportTo(...); Math Tips\rFinding a point in space where player is looking\rIn order to find a point in space where the player is looking, you need to get it\u0026rsquo;s rotator transform it to a vector, add the actor\u0026rsquo;s location and scale the rotation vector.\n1 2 // GetRotation.Vector is the same thing as GetDirection(), Actor.GetDirection * 1000.0f; FVector Point = Actor.GetLocation() + (Actor.GetRotation().Vector * 1000.0f); Interfaces\rInterfaces are useful to create a standardized API that different actors or object might implement. For example, you might want to create an interface that implements two different member functions, such as \u0026ldquo;SaveActor\u0026rdquo; or \u0026ldquo;LoadActor\u0026rdquo;. Making you are actors inherit this interface will make it easier to implement saving and loading of actors.\nActors can also be searched by interface. For example, you might do a search for all actors that implement the \u0026ldquo;Saving/Loading\u0026rdquo; interface.\nWhen an Interface function is marked as BlueprintNativeEvent, the function definition must append \u0026ldquo;_Implementation\u0026rdquo; to it\u0026rsquo;s name.\n1 2 3 4 5 6 7 8 9 // Header UFUNCTION(BlueprintNativeEvent) MyInterfaceFunction() // Definition MyInterfaceFunction_Implementation() { .... } When an interface function is marked as BlueprintNativeEvent or BlueprintImplementable, to call it from C++ you need to prepend \u0026ldquo;Execute_\u0026rdquo; to the function name.\n1 2 3 4 5 6 // Header UFUNCTION(BlueprintNativeEvent) MyInterfaceFunction(); // The function must be called like this Execute_MyInterfaceFunction(); Collision\rCollision Settings\rTry to disable overlaps until required. \u0026ldquo;bGenerateOverlaps = false\u0026rdquo;. Make sure \u0026ldquo;Collision Profiles\u0026rdquo; only react to necessary channels or even better, disable collision entirely. Set \u0026ldquo;Collision Enabled\u0026rdquo; settings to \u0026ldquo;Query Only\u0026rdquo;, unless physics simulation is required. Avoid Hard References wherever possible. Object Channels\rWe can create new collision channels such as WorldStatic or WorldDynamic.\nGo to \u0026ldquo;ProjectSettings-\u0026gt;ObjectChannels-\u0026gt;New\u0026rdquo;.\nShow Collisions\rThe command \u0026ldquo;showcollision\u0026rdquo; enables a visualization of the collision primitives in game.\nMultiplayer\rMultiplayer Gameplay Classes\rClass Where does it exist? PlayerController Exists on the server and on the local client. PlayerState Exists on the server and on all the clients GameMode Only exists on the server GameStateBase Exists on the server and on all the clients. This class is usually used to share GameMode data to all the clients and server Pawn Every Pawn exists on the server and on all the clients also. AIController Exists only on the server How to know if a variable is being replicated in blueprints\rIf a variable is being replicated, the node will have an icon that looks like two cotton balls.\nHow to check if the code is running on the server\rThe function \u0026ldquo;HasAuthority\u0026rdquo; returns true if we are the server\n1 bool bServer = HasAuthority(); Checking what type of client/server we are\rThere\u0026rsquo;s a function call IsNetMode that returns what type of client/server we are. It has more return types that just client or server.\n1 2 3 4 5 6 7 // Examples Modes // - NM_Client // - NM_DedicatedServer // - NM_ListenServer // - NM_MAX // - NM_Standalone World-\u0026gt;IsNetMode(ENetMode Mode); Updating/Replicating Actors\rActors are updated in 2 ways:\nProperty Updates (Automatically send updated variables from server to clients) RPC\u0026rsquo;s (Execute functions on the other machin) Variables are synced from server to client, always!\nMarking an actor to replicate in C\u0026#43;\u0026#43;\rIn order to mark an actor for replication, set it\u0026rsquo;s variable \u0026ldquo;bReplicates\u0026rdquo; to true in it\u0026rsquo;s constructor. If you need to dynamically mark an actor as replicated you can use the \u0026ldquo;SetReplicates\u0026rdquo; function.\n// In Constructor, prefer this over calling SetReplicates directly bReplicates = true; // To set replicate at runtime SetReplicates(true); Replicating Actor Components\rTo set an ActorComponent to replicate, call \u0026ldquo;SetIsReplicatedByDefault(true)\u0026rdquo; in it\u0026rsquo;s constructor.\n1 2 // Constructor SetIsReplicatedByDefault(true); How to setup variables for replication\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Header File // Mark a variable with the Replicated Property UPROPERTY(Replicated, Reliable) int MyReplicatedVariable; // Implementation File // Constructor bReplicates = true; // Remember to set this in the constructor // In the same class, implement the following function and place DOREPLIFETIME macro\u0026#39;s with replication configuration for each variable void AActor::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty) \u0026amp;OutLifetimeProps) const { DOREPLIFETIME(MyClass, MyReplicatedVariable); } Now, the member variable MyReplicatedVariable will be synchronized to all connected clients for every copy of this actor type.\nThere is no need to declare GetLifetimeReplicatedProps in the header file. This is because once we mark a variable as replicated, the unreal header tool will automatically generate the definition for us.\nConditional replication of a variable\rThere\u0026rsquo;s another macro you can use in \u0026ldquo;GetLifetimeReplicatedProps\u0026rdquo; function to configure replication. This is the DOREPLIFETIME_CONDITION() macro.\nThis is mostly used to save bandwith and cpu time. The less data sent, the better. There are a lot of different conditions so be sure to check the official documentation.\n1 2 // Be sure to check the different COND_ macros for different conditions DOREPLIFETIME_CONDITION(Class, Variable, COND_...); Running a function everytime a variable is replicated, OnRep\rReplicated variables can also run a function everytime they change. For this we need to mark the variable with \u0026ldquo;ReplicatedUsing\u0026rdquo; property.\nIn Blueprints, This is called \u0026ldquo;RepNotify\u0026rdquo;\n1 2 3 4 5 UPROPERTY(ReplicatedUsing=\u0026#34;OnRep_LidOpened\u0026#34;, BlueprintReadOnly) bool bLidOpened; UFUNCTION() void OnRep_LidOpened; The convention is to prepend the function name with \u0026ldquo;OnRep_\u0026rdquo;\nOnRep and RepNotify functions are only called automatically on clients. They are not called on the server. If you need this function to be called on the server you must call it manually.\nTypes of Remote Procedure Calls (RPC\u0026#39;s)\rThere are three types of RPC\u0026rsquo;s\nServer RPC's Client RPC's NetMulticast Server RPC\u0026#39;s\rFunctions marked as Server RPC are functions that are designed to be called on the server.\nWhen called from a client, it requests the server to execute a function.\nWhen called from the server, only the server runs the function.\n1 2 UFUNCTION(Server, Reliable) MyFunction(); Client RPC\u0026#39;s\rClient RPC\u0026rsquo;s are called by the server to run on a specific client.\nNetMulticast\rThese are called by the server to run a function on all clients.\nThese are mostly used for transient things such as a barrel explosion. They might not be good for replicating state.\nA new player that enters the server after the multicast was executed, will not receive this explosion event.\nRPC\u0026#39;s Example Declaration and Implementation\r1 2 3 4 5 6 7 8 9 // Header UFUNCTION(Server, Reliable, WithValidation) // Create a reliable server RPC void MyFunctyion(int AParamenter); // Implementation File void AExampleClass::MyFunction_Implementation(int AParameter) { // Stuff } Be aware that the implementation of the function appends \u0026ldquo;_Implementation\u0026rdquo; to the function name.\nRemember to replicate as little data as possible, this includes RPC function parameters!\nCreating RPC\u0026#39;s in Blueprints\rCreate a new custom event Click on it, and select the RPC type on the details panel Select Reliable/Unreliable Reliable / Unreliable\rYou can add a UPROPERTY/UFUNCTION specifier to functions and variables.\nReliable - This will make the variable guaranteed to update on all clients. If a network packet is lost, it will be resent until acknowledgement is received. Be aware that if a reliable packet fails to arrive, the engine will not process new packets until this one has arrived. The player might experience a lag spike.\nUnreliable - Not guaranteed, packet can get lost and it won\u0026rsquo;t be resent.\nUse Unrealiable as much as you can!\nWhere is my code being executed?\rAdd a ton of logging with a variable that shows whether it is running on the client or server.\nWhere should my code be executed?\rChanging Gamestate? Execute on server.\nCosmetic? Execute on client.\nThey are often mixed to predict game state and reduce latency for clients.\nChecking if a PlayerController is being controlled locally\rThere are two functions to check if a controller is being controlled locally.\n1 2 APlayerController-\u0026gt;IsLocalController(); // Also works for AI AController-\u0026gt;IsLocalPlayerController(); // Only works on players IsLocallyControlled()\rThis function returns true if the pawn is controlled locally. It\u0026rsquo;s useful for running code only locally.\n1 Pawn-\u0026gt;IsLocallyControlled(); Blueprint Print Node\rPrinting a string in blueprints while on a multiplayer session will prepend where that node is running on a client or server. Printing \u0026ldquo;Hello World\u0026rdquo; will show up as \u0026ldquo;Client/Server: Hello World\u0026rdquo;\nPlayerState\rEvery player has a \u0026ldquo;player state\u0026rdquo;. It\u0026rsquo;s a class which is automatically replicated to all clients and server. This is a good place to store variables that need to persist such as NumberOfKills.\nGameStateBase\rThis class is usually used to share GameMode data to all the clients and server.\nUsing several replicated variables at the same time\rIf you need more than one replicated variable at the same time, you can wrap these in a struct and replicate the struct.\nNetwork Relevancy\rUnreal has a concept in networking called \u0026ldquo;Relevancy\u0026rdquo;. It\u0026rsquo;s mainly used to select which clients receive what data. For example, two players in fortnite really far away from each other do not need to be updated of each other since they are not near enough for this data to be relevant.\nSadly, this was not covered in the course.\nReplicating UObjects\rUObjects don\u0026rsquo;t have any built-in replication code. So in order to replicate UObjects you need to override the function \u0026ldquo;IsSupportedForNetworking\u0026rdquo; and just return true from it.\nAlso override the function \u0026ldquo;ReplicateSubObjects\u0026rdquo; and inside it call \u0026ldquo;ReplicateSubObject\u0026rdquo;.\n1 Channel-\u0026gt;ReplicatedSubObject(MyObject, *Bunch, *RepFlags); Gotcha\u0026#39;s\rBe careful when destroying actors, if the actor sent an RPC it might get destroyed before it ever sends it.\nBe careful when modifying local variables marked as RepNotifies. If we locally modify a variable, the next time the server updates the value, our OnRep function might not run. Unreal checks for differences in value to choose wether the function runs or not.\nUMG\rCreating a widget in C\u0026#43;\u0026#43;\rTo create a C++ Widget class, inherit from \u0026ldquo;UserWidget\u0026rdquo;.\nInstancing a widget in C\u0026#43;\u0026#43;\r1 2 MyWidget = CreateWidget\u0026lt;MyWidgetClass\u0026gt;(Owner, Class); MyWidget-\u0026gt;AddToViewport(); Removing a widget\rTo remove a widget, call the function:\n1 Widget-\u0026gt;RemoveFromParent(); Accesing Widget variables such as textboxes from C\u0026#43;\u0026#43;\rTo access a UMG widget in C++, do the following:\nCreate a C++ class that inherits from \u0026ldquo;UserWidget\u0026rdquo; Add a class member variable that represents the variable/widget Mark it with UPROPERTY(meta=BindWidget) In the editor create a widget of the same type and name You can now access it from C++ 1 2 3 4 5 6 7 // Remember to create the same variable with the same name and type in the UMG Blueprint UPROPERTY(meta=BindWidget) UTextBlock *MyTextBlock; UPROPERTY(meta=BindWidget) UImage *MyImage; Tick function in widget\rThe tick function in widget\u0026rsquo;s is called \u0026ldquo;NativeTick\u0026rdquo;, override this function when needed.\nAdd widget to another widget\rYou can add other widget to a widget. For example you could have a HUD widget, and health could be another widget. This allows us to separate things and make blueprints more modular.\nAdd boxed as parent to align them\rYou can add Boxes and set the box as parent of other widget to make them auto aligned.\nBind\rYou can click on bind button to add a function that runs every frame and updates the value of something. This is not recommended since running everyfame is very expensive. Prefer using delegates to update values on change/update.\nGet player\u0026amp;rsquo;s character from UMG\ruse GetOwningPlayerPawn to get the player\u0026rsquo;s character\n1 GetOwningPlayerPawn(); Construct/BeginPlay\rConstruct is the BeginPlay of UMG objects. This is a good place to bind to the needed delegates!\nDon\u0026#39;t call widget functions from outside\rDon\u0026rsquo;t create functions inside widgets and call them from actors. Make the UI separate from game code to avoid mantainance nightmares. Never call widgets functions from outside.\nUse PreConstruct to set values\rSet things such as colors and values in the pre construct event.\nMake a widget have input parameters on creation\rChecking \u0026ldquo;Expose on spawn\u0026rdquo; to a variable makes that variable be an input to the CreateWidget node. This way we can set variables when a widget is being created.\nWorld Position to Screen Position\rThe node \u0026ldquo;ProjectWorldToScreen\u0026rdquo; transforms a position in world coordinates to screen coordinates.\nIf the screen coordinate seems weirdly off, try dividing ScreenPosition/GetViewPortScale.\nButtons do not need canvas\rCreating a widget blueprint that is just a button does not need a canvas panel. Setting it to \u0026ldquo;Desired On Screen\u0026rdquo; instead of \u0026ldquo;FillScreen\u0026rdquo; is the way to go for buttons.\nEdit multiple things at the same time\rYou can select multiple things and edit their appereance at the same time.\nInstantiate Widgets by adding them to another widget\rWe can instantiate widgets by adding them to another widget instead of the viewport.\nLet\u0026rsquo;s suppose we have a vertical box inside a widget and we want to add a widget inside this vertical box.\nWe can call VerticalBox-\u0026gt;AddChild and remove it with VerticalBox-\u0026gt;ClearChildren.\nMaterials\rMaterials are just shaders that are programmed using unreal\u0026rsquo;s nodes instead of glsl/hlsl. Materials are the blueprint/classes and material instances are the instances of materials.\nSuch as with glsl uniform variables, you can set input and parameters to a material.\nMaterial Instances\rMaterial instances cannot add/edit behaviours. Only variables exposed by a material are editable.\nMaterial Functions\rYou can create material functions. These functions are able to be reutilized inside other materials.\nMaterial functions can have Input, search for the input node.\nWhen creating a material function, be sure to check the \u0026ldquo;Expose to library\u0026rdquo; checkbox. If you don\u0026rsquo;t do this, the function won\u0026rsquo;t appear in the material function list.\nMaterial Functions can have multiple outputs!\nBuiltin Functions\rThere are a lot of complex functions already implemented for you in the material editor. I recommend having a look at them before implementing something inside a material, there\u0026rsquo;s a chance that what you want is already implemented and the solution might be to add a single node.\nDebugging/Visualizing Scalar Values\rOne way of visualizing scalar values is to use the node \u0026ldquo;DebugScalarValues\u0026rdquo;. It prints a scalar value onto the mesh active in the material. It\u0026rsquo;s a good way of debugging values inside a shader/material.\nUsing Materials in UMG\rIn order to use a material in UMG/User Interfaces, we need to set the Material Domain to \u0026ldquo;User Interface\u0026rdquo;\nSound\rSound Cues\rSound Cues are the programmable audio assets. As with all thing in unreal you can program the sound using it\u0026rsquo;s specific nodes. Maybe add a reverb or something else\u0026hellip;\nAnim Blueprints\rThe event graph run every frame! To be more specific, the \u0026ldquo;Event Blueprint Update Animation\u0026rdquo; runs every frame.\nThe event graph inside an animation blueprint is able to set variables which are to be used inside the animation graphs to set the correct pose.\nAI\rDebugging Tips\rPress the apostrophe key (\u0026rsquo;) to open the in-game AI Debugger. There\u0026rsquo;s a lot of information there. Press the key while looking at an AI to show the info about it\u0026rsquo;s ai instance\nDebugging Tip -\u0026gt; We can use the \u0026ldquo;visual logger\u0026rdquo; to record gameplay and then see what was happening at different points of the playthrough. It can record a lot of events, suchs as EQS, BT\u0026rsquo;s, Pathfinding and more. It\u0026rsquo;s also good to note that the visual logger has a lot more features than AI debugging tools.\nBehaviour Trees\rTo get the behaviour tree from C++, call the function:\n1 AIController-\u0026gt;GetBrainComponent(); Navmesh\rNavmesh: The navmesh provides data on where the AI is allowed to move.\nThe navmesh might create valid sections inside big meshes. This might generate bugs, such as EQS generating points inside meshes. To fix this, create \u0026ldquo;Nav Modifier Volumes\u0026rdquo; and place them to delete the invalid navmesh sections.\nAIController\rWhen creating an AIController in C++ it still needs a blueprint that inherits from it.\nBlackboard Component\rYou can get the blackboard component in AIController with the function GetBlackboardComponent\nTo change a value in a blackboard component, use the function:\n1 BlackboardComponent-\u0026gt;SetValueAs...(...) BTServices\rTo create BTServices in C++ you need to inherit from \u0026ldquo;BTService\u0026rdquo;, if you are creating them from Blueprints, inherit from \u0026ldquo;BTService_BlueprintBase\u0026rdquo;.\nIn order to not hardcode blackboard keys as test in C++, you can create a variable like the following and set the key on the editor.\n1 2 UPROPERTY(EditAnywhere) FBlackboardKeySelector MyKey; To run a Service each frame, add the frame to the rootnode of the Behavior Tree.\nBTTasks\rTo create a BTTask node in C++, inherit ftrom BTTaskNode. To create one in blueprints, inherit from BTTask_BlueprintBase.\nMarking values with UPROPERTY specifiers, make these variables editable inside the behaviour tree when selecting the corresponding node.\nDecorators\rDecorators have a vew flow control capabilities inside the details window of a decorator. Let\u0026rsquo;s say we have a decorator that depends on a bool. To instantly stop execution on that subtree when this bool changes, set NotifyObserver to: \u0026ldquo;OnResultChange\u0026rdquo; and ObserverAborts to: Self.\nIf you click on a decorator, unreal engine will apply color to different nodes. For example, unreal will color light blue those nodes that are aborted by low priority mode. Green those that are aborted by mode Self. Unreal always colors the nodes that are affected from what we have currently selected.\nEQS\rRunning an EQS Query from C\u0026#43;\u0026#43;\rTo run an EQS Query from C++, call:\n1 UEnvQueryManager::RunEQSQuery(...); EQS Queries might take multiple frames to complete. Remember to bind to \u0026ldquo;GetOnQueryFinishedEvent\u0026rdquo; to handle the query results.\nEQS From BT\u0026#39;s\rWhen running an EQS from a BT, remember to set the key for the output value. For example, if running a query that will return a location, remember to set the output location key.\nEQS Scoring Factor\rSetting the scoring factor to a negative number makes the test weigh more in score.\nEQS Querier\rThe \u0026ldquo;Querier\u0026rdquo; is the class that is running the query. If we run it from a BT, the querier is the AI running that BT. Queries can also be called from other classes such as game mode.\nRunning a Query from a non AI actor\rWe can run the query from another \u0026ldquo;center\u0026rdquo;, meaning a non existant EnvQueryContext. To do this we need to create a QueryContesxt. It\u0026rsquo;s a blueprint or C++ class that inherits from EnvQueryContext_BlueprintBase or the C++ one. Then, override one of the four functions and provide the possible actors/locations from which the query can be made.\nDebugging Tips\rYou can create a special actor to visualize EQS queries in the editor. First create a blueprint that inherits from \u0026ldquo;EQSTestingPawn\u0026rdquo;, drop it in the world. Set the EQS query you want to visualize and, move the actor around to try and \u0026ldquo;refresh\u0026rdquo; it. If it all went well you should see the differentes EQS spheres and their results.\nIn the AI Visual debugger (\u0026rsquo;) key, press numpad 3 to enable EQS visualization for the selected AI. Blue means it failed, green succeeded. Each sphere is a queried location/point.\nEQS Gotcha\u0026#39;s\rIf the navmesh is not carefully created and cleaned, EQS might generate points on invalid areas, such as inside big meshes.\nSenses\rAI\u0026rsquo;s can have what unreal calls \u0026ldquo;senses\u0026rdquo;, such as seeing, listening for sounds and more. In the course we mainly used the \u0026ldquo;PawnSensingComponent\u0026rdquo; but there\u0026rsquo;s a new API called \u0026ldquo;AI Perception\u0026rdquo;. This new API should be used.\nIn the details pane of the \u0026ldquo;PawnSensingComponent\u0026rdquo; you can edit some values for the senses. Such as peripheral vision angle, which is a cone that represents the AI vision.\nCurves\rUnreal has an easy way to create curves for various purposes. To create a curve open the right click menu, and under \u0026ldquo;Misc\u0026rdquo; select and create a Curve. Set a few points to create the desired curve. You can access the curve from C++ by creating a variable:\n1 UCurveFloat *MyCurve; Commands and Cheats\rExec\rMarking a function as Exec allows it to be called as a command in the game console.\nThis will work automatically as long as the function is in:\nPlayerController Character you are playing with GameMode CheatManager Cheat Manager\rDerive a class from UCheatManager and you can add the cheats there.\nStat Commands\rThere a lot of stat commands, type \u0026ldquo;stat\u0026rdquo; in the console to see a list of them.\nSome useful stat commands:\nstat unit stat graph stat uobjects (Shows number of instances of objects. Useful to find memory leaks / objects that are not being destroyed). You can also create your own stat commands.\nTom Looman has a nice article explaining how to do custom stat traces \u0026amp; commands.\nSavegame System\rLocation of saved game files\rSave files are stored in: \u0026ldquo;ProjectName/Saved/SaveGames\u0026rdquo;\nOverview of SaveGame implemented in the course\rIn the course we started by creating a new class that inherited from SaveGame.\nThen we created a new variable and marked it with UPROPERTY so unreal can find it later.\nWe created two functions inside GameMode\nWriteSaveGame(); LoadSaveGame(); Loading SaveGame\rIn GameMode we called our LoadGame function inside StartPlay.\nSaveGame UObject\rIt\u0026rsquo;s a container to store variables like \u0026ldquo;Earned Credits\u0026rdquo;, unlocked abilities, player level, etc\u0026hellip;\nSaving on C\u0026#43;\u0026#43;\rThis will be an example of saving and loading a single variable called \u0026ldquo;Credits\u0026rdquo;\nCreate SaveGame UObject Instance Copy Creditos from PlayerState into SaveGame Call UGameplayStatics::SaveGameToSlot(); Done! Loading on C\u0026#43;\u0026#43;\rCheck if SaveGame file exists UGameplayStatics::LoadGameToSlot(); Copy Loaded credits of SaveGame into PlayerState Done! SaveGame Functions in GameplayStatics\r1 2 3 4 SaveGameToSlot(); LoadGameFromSlot(); DoesSaveGameExist(); CreateSaveGameObject(); Saving/Loading Actor State\rMark desired variables to save with the SaveGame UPROPERTY Saving\rIterate through all actors in the world. Find relevant actors based on Interface, Class, Tags, etc.. Actor-\u0026gt;Serialize(EmptyArchive), this will convert all variables marked with SaveGame into an FArchive(Binary) Add resulting binary data containing serialized Actor Data into a SaveGame UObject Loading\rGet binary data from SaveGame object. Iterate Actors in world. Find matching actors by name from available SaveGame Data. Actor-\u0026gt;Serialize(FilledArchive) This will convert binary data into actor\u0026rsquo;s variables. Saving/Loading moved actors\rSaving\rIterate over actors in the world. Find relevant actors, maybe by if they implement an interface, the type of class, if they have some tags. This is your choice. Create a struct to hold the actor\u0026rsquo;s Name and Transform. If the actors were moved we need to save their new location. Add struct into SaveGame Object Loading\rLoad Actor data (the array with names and transforms). Iterate actors in the world. Find matching Actors by Name in our SaveGame data. Move each Actor to it\u0026rsquo;s saved Location. Actor-\u0026gt;SetActorTransform(LoadedTransform). Serialize Save Data\rIn order to serialize and store an actor\u0026rsquo;s variables marked as SaveGame. We need to create an array of bytes in SaveGame where the binary data will be stored.\nSerializing and storing API is not particularly clear, you need to do something that looks like the following:\n1 2 3 4 5 6 7 8 9 10 // Pass the array to fill FMemoryWriter(ActorData.ByteArray); FObjectAndNameAsStringProxyArchive Archive(MemWriter, true); // Find only variables with UPROPERTY(SaveGame) Archive.ArIsSaveGame = true; // Converts actor savegame properties into Binary Array Actor-\u0026gt;Serialize(Archive); Load Serialized Actor Data\rIt\u0026rsquo;s similar to save serialized data, but we use a memory reader instead of a writer.\n1 2 3 4 5 6 FMemoryReader MemReader(ActorData.ByteArray); // This will load saved variables onto Actor FObjectAndNameAsStringProxyArchive Ar(MemReader, true); Ar.ArIsSaveGame = true; Actor-\u0026gt;Serialize(Ar); After loading variables be sure to run the procedures that put all the remaining state back.\nExample: If the actor has a bIsOpen variable, remember to update it\u0026rsquo;s state. Set the door open.\nIt might be a good idea to create a Save/Load interface for actors. Call OnSave when saving, OnLoad when loading.\nSaving Player Settings\rPlayer settings should not be saved in SaveGame class, there is a separate class for this!\nData Tables\rData tables are basically a spreadsheet with data. It can be created and filled inside the editor or it can be populated with a CSV import.\nThey cannot be modified at runtime\nThe can be accesed in C++ by UDataTable*\nDatatables in C\u0026#43;\u0026#43;\rIn order to use data tables in C++, we also need to create a struct that represents a single data table row with all of its variables.\nThis struct must inherit from FTableRowBase.\nLater, we can create a datatable in the editor and make it of the type struct we defined.\nData Assets\rData assets and data tables are a good to store separate data from code.\nWe can create a data asset for each monster and hold all of it\u0026rsquo;s variables there, like health and anything else.\nLater, when we want to edit one of those values, it\u0026rsquo;s all contained there and we won\u0026rsquo;t need to go through code to change things.\nData Asset in C\u0026#43;\u0026#43;\rCreate a C++ class that inherits from PrimaryDataAsset. Inheriting from PrimaryDataAsset will let us use the AssetManager with this data asset.\nSoft and Hard References\rHard References\rHard references are always loaded synchronously when they are referenced by another object. This means that when trying to load a single \u0026ldquo;stone\u0026rdquo; actor we might load everything instead.\nThis can quickly make the game slow to load, and make the development experience also slow.\nExamples of hard references:\nTSubClassOf Pointers to assets Casting to certain classes are also hard references Soft References\rSoft references are not loaded automatically, they need to be loaded manually.\nThey require management of loading in code. They load in the background and avoid game freezes. They reduce load screens and memory use by loading data on the fly. Tools to see reference status in your project\rSize Map - This tool shows all the hard references of an object/actor. It will let you quickly see if that stone is in fact loading everything because of hard references.\nReference Viewer - View asset references, oftean reveal unnecessary Cast or references to other content.\nSoft references in C\u0026#43;\u0026#43;\rTo turn a UTexture2D hard reference into a soft ptr, do:\n1 2 3 4 5 // Replace UTexture2D *Img; // With this TSoftObjectPtr\u0026lt;UTexture2D\u0026gt; Img; In UE5+, when converting a C++ hard reference to soft. When we compile, the engine will add a new node where the hard reference was used. This new node automatically returns null if the object is not already loaded in memory. It will not load it. We still have to manually load it. Be sure to check and correct everything when changin from hard to soft.\nRemember, you will need to manually load this asset in code.\nLoading soft references in blueprints\rUse the node \u0026ldquo;Async Load Asset\u0026rdquo;.\nSoft references tips\rDon\u0026rsquo;t make everything a soft reference. It will become hell to manage.\nMake smart and tactical decisions of which objects should be soft pointers.\nData Assets and Data Tables are a good example.\nThey are just data containers, but they are also hard referencing things. What looks like a small data asset might really be a lot of Megabytes when loaded into memory.\nSoft pointers in C\u0026#43;\u0026#43;\r1 2 3 4 5 // Used for references of content such as UTexture2D, UParticleSystem, etc.. TSoftObjectPtr\u0026lt;T\u0026gt; MyObjectPtr; // Used to hold classes TSoftClassPtr\u0026lt;T\u0026gt; MyClassPtr; Async Loading of individual assets\rFStreamableManager (C++) or Blueprint nodes such as AsyncLoadAsset. These two load base content such as textures, particle systems, etc\u0026hellip;\nAsset Manager\rThe Asset manager is mainly used to load Data Assets. In order to load those data assets you need to provide an FPrimaryAssetId. It will use this Id to identify what to load.\nThe asset manager needs to be configured in the project settings. Inside the \u0026ldquo;Game-\u0026gt;AssetManager\u0026rdquo; we need to add a new \u0026ldquo;Primary Asset Types to Scan\u0026rdquo;.\nExample: Primary Asset Type: \u0026ldquo;Monsters\u0026rdquo;. Asset Base Class: \u0026ldquo;SMonsterData\u0026rdquo; (This a data asset type). Directories: Add directory where to search\nLoads PrimaryDataAsset asynchronously by providing FPrimaryAssetID of an asset.\nLoads a DataAsset that can contain a bunch of different content to load all at once.It\u0026rsquo;s a wrapper around FStreamableManager, it\u0026rsquo;s specific to loading/unloading DataAssets.\nTo find a Data Asset with the asset manager, we need to override a function in our data asset C++ implementation.\nExample:\n1 2 3 4 FPrimaryAssetId GetPrimaryAssetId() const override { return FPrimaryAssetId(\u0026#34;Monsters\u0026#34;, GetName()); } Now, instead of a pointer to a data asset, we change it to a FPrimaryId, and use this id to load it.\n1 2 3 4 5 // Change this USMonsterData *MyDataAsset; // To this FPrimaryAssetId MyDataAssetId; Accessing the asset manager from C\u0026#43;\u0026#43;\r1 UAssetManager *Manager = UAssetManager::GetIfInitialized(); Loading an asset\r1 2 3 4 5 6 7 8 9 10 UAssetManager *Manager = UAssetManager::GetIfInitialized(); // The delegate and the function it triggers can have parameters if you need them FStreamableDelegate Delegate = FStreamableDelegate::CreateUObject(This, MyFunction); TArray\u0026lt;FName\u0026gt; Bundles; Manager-\u0026gt;LoadPrimaryDataAsset(AssetId, Bundles, Delegate); // The Delegate function will be triggered once the action has been loaded. Getting a reference to the actual data\rOnce the asset has finished loading and the delegate function is triggered, we can now get a pointer to the data once again using the asset manager.\n1 UMyData *MyData = Cast\u0026lt;UMyData\u0026gt;(Manager-\u0026gt;GetPrimaryAssetObject(MyId)); Asset Manager Bundles\rBundles are a way to select what to load inside a data asset. If we only need one section of the data asset, we can load that part by using bundles.\nFPrimaryAssetId\rThe id is basically an FName and we can set variables to be of this type.\nProfiling\rAlways cook before profiling. Packaging and cooking may resutl in better performance.\nUnreal Insights\rYou can add \u0026ldquo;Bookmarks to your code and make the section of the code you marked, appear in insights by name\u0026rdquo;.\nCooking/Packaging\rAdd levels to be packaged\rIn order to package the project correctly, we need to add the specific levels we want to package. By adding these levels everything reference by them will be automatically cooked and packaged.\nGo to Packaging settings and add the desired levels to: \u0026ldquo;List of maps to include in a packaged build\u0026rdquo;.\nSomething not working in a packaged build?\rMaybe some things related to the asset manager might not be working in the packaged build. Try settings the cooking rule for that type of asset to \u0026ldquo;Always Cook\u0026rdquo;.\n\u0026ldquo;Game-\u0026gt;AssetManager-\u0026gt;Primary Type Asset To Scan-\u0026gt;Rules-\u0026gt;CookRule\u0026rdquo;.\nPerformance Tips\rAvoid Ticking of Actors and Components\rMost logic can be done through events or timers with lower frequency than ticks.\n","date":"Mar 20","permalink":"https://jsanchez.net/post/tom_looman_course_notes/","tags":null,"title":"Notes from Professional Game Development in C++ and Unreal Engine"},{"categories":null,"contents":"\rWhat is collision detection?\rWikipedia defines collision detection as \u0026ldquo;the computational problem of detecting the intersection of two or more objects\u0026rdquo;. In real life you cannot go through objects but in a computer simulation objects can overlap and go through each other. In order to resemble reality we need a way to detect when objects are overlapping.\nImagine two billiard balls, one of them is moving towards the other. In the real world they collide and each ball goes in a different direction. When programming a simulation we need to check every frame for collision, and when a collision is found resolve it.\nCollision detection is a broad and complex problem, and if that wasn\u0026rsquo;t enough it is also coupled with simulations and physics.\nIn this article I will only talk about collision detection of two or more circles in 2 dimensions(although the same algorithm works for 3D spheres), and to make it a little more fun I will explain one of the many ways of making things interact besides checking if they are colliding or not.\nHere\u0026rsquo;s a preview of what we will be implementing.\nPrerequisites\rI have to draw the knowledge required line somewhere, and this is it. Nothing of what i\u0026rsquo;m about to explain/use is hard or complex. You can learn it in a few minutes. The internet is full of guides and this one will do the job just fine.\nThese are the things you need to know:\nWhat is a circle\u0026rsquo;s radius What is a vector Subtracting two vectors Magnitude of a vector Normalizing a vector Scaling a vector I will be programming in C since it\u0026rsquo;s my favourite language, feel free to translate the code to your language and style of your choice. Let\u0026rsquo;s start by defining vector and circle structs.\n1 2 3 4 5 6 7 8 9 10 typedef struct vec2 { float x, y; } vec2; typedef struct circle { vec2 Center; // Center are the coordinates of the circle center float Radius; } circle; Now let\u0026rsquo;s define some functions we will need.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 vec2 Subtract(vec2 A, vec2 B) { vec2 Result = {0}; Result.x = A.x - B.x; Result.y = A.y - B.y; return Result; } float Magnitude(vec2 A) { return sqrtf(A.x * A.x + A.y * A.y); } vec2 Normalize(vec2 A) { vec2 Result = {0}; float Length = Magnitude(A); Result.x = A.x / Length; Result.y = A.y / Length; return Result; } Checking if two circles collide\rChecking if two circles collide is really easy. If the distance between the two circle\u0026rsquo;s center is less than the sum of their radii, they are colliding. Play around with the following example and you should get the idea. The black line represents the distance between the two circles, and the radii sum is just the sum of both circle\u0026rsquo;s radii.\nThe code\rThe following function returns just a boolean, wether the input circles are colliding or not.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool Collide(circle A, circle B) { vec2 Difference = Subtract(A.Center, B.Center); float Distance = Magnitude(Difference); float RadiiSum = A.Radius + B.Radius; if(Distance \u0026lt; RadiiSum) { return true; } else { return false; } } Basic collision interaction\rHere we are going to do the red and blue circle interaction seen on the first section.\nIn order to move the circles apart we need what is called the \u0026ldquo;minimum translation vector\u0026rdquo;, in other words it\u0026rsquo;s how much the circles are overlapping. With this length, we can simply move both circles apart or just one as i did with the red one.\nTo get the minimum translation vector we subtract the distance from the radiisum and take the absolute value of the result. After that we need to get the normalized direction vector of the distance. After that we just need to add the movement to the red circle.\nMath in words makes everyone dizzy, and i\u0026rsquo;m not good at explaining. Code is a more elegant medium.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Simulate(circle A, circle *B) { // Be aware that circle B is a pointer, this is because we are // going to update it\u0026#39;s position. B is the same as the red circle // in the previous demo window. // Abs -\u0026gt; Absolute value // MTD -\u0026gt; Minimum translation distance if(Collide(A, *B)) { float RadiiSum = A.Radius + B-\u0026gt;Radius; float MTD = Abs(Distance - RadiiSum); vec2 Direction = Normalize(Subtract(A.Center, B-\u0026gt;Center)); B-\u0026gt;x += Direction.x * MTD; B-\u0026gt;Y += Direction.y * MTD; } } This last section is a bit more complicated, if you don\u0026rsquo;t understand something, i recommend doing sketches on pen and paper, that usually helps me.\nI\u0026rsquo;m happy you read this whole thing, thank you, you are awesome.\nUntil next time.\n","date":"Apr 05","permalink":"https://jsanchez.net/post/collision_circle_circle/","tags":null,"title":"Collision Detection: Circle vs Circle"},{"categories":null,"contents":"Dear Imgui is an awesome C/C++ immediate mode graphical user interface (GUI) made by ocornut. It provides just about every widget you might need, buttons, color pickers, plots and many, many more. It\u0026rsquo;s also fast and super easy to use.\nHere\u0026rsquo;s a screenshot of someone\u0026rsquo;s game using Dear ImGui.\nCool uh?. It\u0026rsquo;s easy to integrate into your project. The official documentation says integration should take you less than 3 hours. That\u0026rsquo;s a lot of features and awesomeness for such a short amount of time.\nI personally build my projects using unity builds(also called single translation unit compilation). I could not find any guide on how to setup dear imgui for this type of build system.\nSo here\u0026rsquo;s how i did it.\nWhat are unity builds?\rThe standard way of building C/C++ applications is to build each .c/.cpp file separately (each instance is called a translation unit) and link all of them at the linker stage producing the executable.\nUnity build\u0026rsquo;s basic idea is to include every .c/.cpp source file in a single file, and after the preprocessor runs you have just one huge file to compile. Unity builds also have faster compilation time, even while rebuilding the whole project each time. I have seen codebases bigger than 150000 lines compile in a second. really.\n1 2 3 4 5 6 7 8 #include \u0026#34;my_other_file.cpp\u0026#34; #include \u0026#34;my_other_file2.cpp\u0026#34; #include \u0026#34;my_other_file3.cpp\u0026#34; int main() { // My program... } 1 jsanchez@scarlet:~$ cl main.cpp If you are not compiling your code like this, you don\u0026rsquo;t need to follow this guide. Head over to the official integration guide.\nCopying files to your project\rStart by downloading Dear ImGui. We are going to select a few source code files from the zip and copy them to our project, feel free to extract it wherever you prefer.\nImGui is meant to be used on many operating systems, alongside many platform libraries and every major rendering api. In order to do its job it needs to read keyboard/mouse/gamepad input, upload textures/buffers to the gpu and render. There\u0026rsquo;s a lot of glue code to be done here. Luckily there are many \u0026ldquo;backends\u0026rdquo; ready for you to use.\nIn my case i\u0026rsquo;m using libSDL for my platform code and OpenGL 3.3 as my rendering api. So i need to use the two following backends imgui_impl_sdl and imgui_\rimgui_impl_opengl3. You can find all available backends inside the backends directory.\nNow, create a folder inside your project to hold the Dear ImGui files. Copy the following files from the root directory of the Dear ImGui zip file.\nimconfig.h\rimgui.h\rimgui.cpp\rimgui_draw.cpp\rimgui_demo.cpp\rimgui_internal.h\rimgui_tables.cpp\rimgui_widgets.cpp\rimstb_rectpack.h\rimstb_textedit.h\rimstb_truetype.h Also copy the following files from the backends directory. If you are not using libSDL and OpenGL you will need to replace the following files with whatever files you need.\nimgui_impl_opengl3.cpp\rimgui_impl_opengl3.h\rimgui_impl_opengl3_loader.h\rimgui_impl_sdl.h\rimgui_impl_sdl.cpp Remember to add the new directory holding this files to the project\u0026rsquo;s include path.\nWe are now ready to open our text editor, and because we are using unity builds:\nInstead of doing this.\n1 2 3 #include \u0026#34;imgui.h\u0026#34; #include \u0026#34;imgui_impl_sdl.h\u0026#34; #include \u0026#34;imgui_impl_opengl3.h\u0026#34; We do this!\n1 2 3 4 5 6 7 #include \u0026#34;imgui.cpp\u0026#34; #include \u0026#34;imgui_tables.cpp\u0026#34; #include \u0026#34;imgui_widgets.cpp\u0026#34; #include \u0026#34;imgui_draw.cpp\u0026#34; #include \u0026#34;imgui_demo.cpp\u0026#34; // You don\u0026#39;t need this file, i use it as gui reference #include \u0026#34;imgui_impl_opengl3.cpp\u0026#34; #include \u0026#34;imgui_impl_sdl.cpp\u0026#34; We are almost ready to use Dear ImGui. There\u0026rsquo;s just one more problem.\nOpenGL loader clash\rOpenGL is generally implemented in the video driver, and before using it you need to query the driver for function pointers. ImGui has it\u0026rsquo;s own loader but it\u0026rsquo;s not a replacement for a full opengl loader like glad. Since you now have two loaders, your code will not compile because there will be multiple function pointer redefinitions.\nTo solve this #define IMGUI_IMPL_OPENGL_LOADER_CUSTOM before you include your OpenGL loader.\n1 2 #define IMGUI_IMPL_OPENGL_LOADER_CUSTOM #include \u0026#34;glad.c\u0026#34; You are now ready to write some code. You need to write some minimal boilerplate code to get ImGui up and running. I recommend checking the examples directory inside ImGui\u0026rsquo;s zip file and running ImGui\u0026rsquo;s example demo window to get an idea of what can be done. I hope this helps.\nSee you next time!\n","date":"Feb 22","permalink":"https://jsanchez.net/post/integrating_imgui_in_unity_builds/","tags":null,"title":"Integrating Dear ImGui in unity builds"},{"categories":null,"contents":"Let\u0026rsquo;s say you want to allocate a struct that contains a pointer to other data that also needs allocation. The natural way to do it is calling malloc twice, one for the container and one for the data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* The natural way to allocate a struct and its data */ struct sample_type { float A; uint32_t B; uint8_t C; bool D; bool E; bool F; bool G; }; struct sample_struct { uint32_t Count; sample_type *Data; }; uint32_t Count = 5; sample_struct *Container = (sample_struct*)malloc(sizeof(sample_struct)); Container-\u0026gt;Count = Count; Container-\u0026gt;Data = (sample_type*)malloc(sizof(sample_type) * Count); // Do something to the data for(int i = 0; i \u0026lt; Container-\u0026gt;Count; i++) { Container-\u0026gt;Data[i] = {}; } Something doesn\u0026rsquo;t feel right, these two allocations are going to be used together, one after the other but there is no guarantee they will be contiguous in memory, a cache miss is likely to happen everytime you access the data.\nHere is one way to use just a single allocation for the container and its data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Using a single allocation */ struct sample_type { float A; uint32_t B; uint8_t C; bool D; bool E; bool F; bool G; }; struct sample_struct { uint32_t Count; sample_type *Data; }; uint32_t Count = 5; sample_struct *Container = (sample_struct*)malloc( sizeof(sample_struct) + sizeof(sample_type) * Count); Container-\u0026gt;Count = Count; Container-\u0026gt;Data = (sample_type*)(Container + 1); // Do something to the data for(int i = 0; i \u0026lt; Container-\u0026gt;Count; i++) { Container-\u0026gt;Data[i] = {}; } If you ask me the second version is better, a single call to malloc and things that belong together are adjacent in memory.\nThere is something you need to be aware of while using this trick, Data should always be the last member of the struct.\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct sample_struct { uint32_t Count; sample_type *Data; float Other; // WRONG, writing to this variable will overwrite values in the Data array and vice versa. }; struct sample_struct { uint32_t Count; float Other; // CORRECT, Remember to add struct members before the Data array. sample_type *Data; }; ","date":"Jun 26","permalink":"https://jsanchez.net/post/avoiding-double-allocation-for-structs-and-data/","tags":null,"title":"Avoiding double allocation for structs and data"},{"categories":null,"contents":"If you have been using OpenGL for a while, you probably have a lot of shader files, maybe one for each programmable stage of the pipeline. At some point during development the directory that contains the shaders becomes a mess, managing and opening shader files in your editor becomes tedious. Luckily there\u0026rsquo;s a way to cram all the programmable shader stages in a single file, reducing the number of files at least by half and calm the neat freak inside.\nThese are the two things that make this trick possible.\n#ifdef - glsl\u0026rsquo;s preprocessor directive glShaderSource() The idea is to separate different shader stages inside an #ifdef blocks and setting the corresponding #define directive for the shader stage.\nHere\u0026rsquo;s an example of what a shader might look like using this method.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #ifdef VERTEX_SHADER layout(location = 0) in vec3 Vertices; layout(location = 1) in vec3 Normals; uniform mat4 Model; uniform mat4 View; uniform mat4 Projection; void main() { gl_Position = Projection * View * Model * vec4(Vertices, 1.0); } #endif #ifdef FRAGMENT_SHADER uniform vec3 Color; out vec4 FragColor; void main() { FragColor = vec4(Color, 1.0); } #endif Shader compilation looks something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 char *SourceFile = ReadTextFile(\u0026#34;MyShader.glsl\u0026#34;); // Compile Vertex Shader u32 VertexShaderObject = glCreateShader(GL_VERTEX_SHADER); char *VertexSource[2] = {\u0026#34;#version 330 core\\n#define VERTEX_SHADER\\n\u0026#34;, SourceFile}; glShaderSource(VertexShaderObject, 2, VertexSource, NULL); glCompileShader(VertexShaderObject); // Compile Fragment Shader u32 FragmentShaderObject = glCreateShader(GL_FRAGMENT_SHADER); char *FragmentSource[2] = {\u0026#34;#version 330 core\\n#define FRAGMENT_SHADER\\n\u0026#34;, SourceFile}; glShaderSource(FragmentShaderObject, 2, FragmentSource, NULL); glCompileShader(FragmentShaderObject); // Compile other shader stages // Link program u32 FinalProgram = glCreateProgram(); glAttachShader(FinalProgram, VertexShaderObject); glAttachShader(FinalProgram, FragmentShaderObject); glLinkProgram(Result); Notice that before calling glShaderSource we create an array of two pointers to char, the first one contains glsl\u0026rsquo;s #version preprocessor directive and the token that defines each shader. In the case of the vertex shader the first string looks like this \u0026ldquo;#version 330 core\\n#define VERTEX_SHADER\\n\u0026rdquo;. Sadly the #version directive needs to be the first line in a shader or else compilation fails. Setting the shader version like this is not as pretty or tidy as we may want but it\u0026rsquo;s a tradeoff i\u0026rsquo;m willing to make. When calling glShaderSource we set the second parameter to \u0026ldquo;2\u0026rdquo; indicating 2 strings and set the string to our newly created array.\nI hope you find this useful.\n","date":"Dec 09","permalink":"https://jsanchez.net/post/multiple-shaders-in-one-file/","tags":null,"title":"Multiple OpenGL shaders in a single file"},{"categories":null,"contents":" 1 2 3 4 5 6 7 8 9 10 11 // Normalize an input value to 0,1 range. f32 Normalize(f32 Input, f32 Minimum, f32 Maximum) { return (Input - Minimum) / (Maximum - Minimum); } // Map one range onto another. Ex: Map Value Between 0-1800 to -20, 20. f32 Remap(f32 Input, f32 InputStart, f32 InputEnd, f32 OutputStart, f32 OutputEnd) { return (Input - InputStart) / (InputEnd - InputStart) * (OutputEnd - OutputStart) + OutputStart; } GLSL\r1 2 3 4 5 6 7 8 // Grayscale FragmentColor = texture(SampledTexture, UV); float Average = (0.2126 * FragmentColor.r) + (0.7152 * FragmentColor.g) + (0.0722 * FragmentColor.b); FragmentColor = vec4(Average, Average, Average, 1.0); // Gamma Correction const float Gamma = 2.2; FragmentColor = pow(FragmentColor, vec3(1.0 / Gamma)); ","date":"Dec 07","permalink":"https://jsanchez.net/post/glsl-gists/","tags":null,"title":"Gists/Snippets"},{"categories":null,"contents":"Hybrid GPU\u0026rsquo;s are everywhere these days and yet it is not obvious how to run your program using the discrete GPU.\nI can think of 5 ways on how to get this done:\nYour software is popular enough that the GPU manufacturer includes an \u0026ldquo;application profile\u0026rdquo; for your software in their driver. This profile is basically the GPU configuration/settings for an executable. When your software has no application profile, the default graphic card depends on the global GPU settings but it is most likely the integrated gpu. You can manually create an application profile for your executable. The problem is that this profile will need to be manually created for each install. This may be useful if it\u0026rsquo;s a silly program you alone are going to run, but not really an option if you plan to ship software, even if it\u0026rsquo;s to family and friends. Oddly enough you can trick the driver to use an application profile made for other software by simply renaming your executable to something like \u0026ldquo;Doom3.exe\u0026rdquo;. Not really a solution but it\u0026rsquo;s comforting to know simple tricks like these still exist in 2019. Linking your program against nVidia\u0026rsquo;s defined libraries such as \u0026ldquo;nvapi64.dll\u0026rdquo;(The list of libraries is defined in the manual at the bottom of the page). Calling HMODULE Lib = LoadLibraryA(\u0026ldquo;nvapi64.dll\u0026rdquo;) in main function does the trick. This seems to be the old way of doing things, continue reading for a better solution. The best solution i know is to include the following code at global scope. 1 2 3 4 5 6 7 8 9 #ifdef _WIN32 extern \u0026#34;C\u0026#34; { // nVidia __declspec( dllexport ) unsigned long int NvOptimusEnablement = 0x00000001; // AMD __declspec( dllexport ) int AmdPowerXpressRequestHighPerformance = 1; } #endif I have only tested the code on nVidia Optimus since it\u0026rsquo;s the only thing i have.\nIf you would like to know more, you should read the following manuals for Hybrid GPU\u0026rsquo;s, they are really really short (4-5 pages).\nnVidia\u0026rsquo;s hybrid gpu manual\nAMD\u0026rsquo;s hybrid gpu manual\n","date":"Dec 07","permalink":"https://jsanchez.net/post/handling-hybrid-gpus-in-windows/","tags":null,"title":"Handling Hybrid GPU's in Windows"},{"categories":null,"contents":"When you need a muli-line macro to have its own scope and behave as a regular function would, the naive way is to simply wrap the macro statements inside curly brackets. Now, time has passed and suddenly program compilation is failing, and as usual the compiler output is not helping. The naive macro implementation has come back to bite you.\nHere\u0026rsquo;s the naive implementation, let\u0026rsquo;s see how to fix it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define MyMultipleLineMacro(Expr) \\ { \\ DoStuffRightHere(Expr); \\ DoMoreStuff; \\ } \\ void main() { if(1) MyMultipleLineMacro(Input); // Fails to compile! else SomeOtherOperation; } Let\u0026rsquo;s run the preprocessor and see how the macro was expanded:\n1 2 3 4 5 6 7 8 9 10 void main() { if(1) { DoStuffRightHere(Input); DoMoreStuff; }; // Fails to compile! else SomeOtherOperation; } To solve this problem, wrap the macro inside a do{}while(0) loop instead.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define MyMultipleLineMacro(Expr) \\ do{ \\ DoStuffRightHere(Expr); \\ DoMoreStuff; \\ }while(0) \\ void main() { if(1) // Now the macro expands to valid C/C++. do { DoStuffRightHere(Input); DoMoreStuff; }while(0); else SomeOtherOperation; return 0; } Have a good day!\n","date":"Jun 22","permalink":"https://jsanchez.net/post/multi-line-function-macro/","tags":null,"title":"Making multi-line macros behave as a functions"}]